# Java_Spring_Boot
Ceci est l'application de la formation Spring Boot proposer par OpenClassroom : https://openclassrooms.com/fr/courses/6900101-creez-une-application-java-avec-spring-boot

## Partie 1 - Identifiez pourquoi et quand utiliser Spring Boot
### Explorez les solutions apport√©es par Spring

Quelle est notre probl√©matique de base ? Construire une application qui :
1. Permet de r√©pondre aux besoins fonctionnels actuels.
2. Permettra de r√©pondre aux futurs besoins.
3. Et cela de fa√ßon efficiente !

> Un d√©veloppement **efficient** est un d√©veloppement **efficace**, c‚Äôest-√†-dire qui atteint les objectifs du projet mais en plus **√† moindre co√ªt**, avec **moins de ressources** humaines et en **moins de temps** ! 

#### Impl√©mentez un code √©volutif gr√¢ce au pattern Dependency Injection
> Comment √™tre capable de r√©pondre aux besoins futurs si on ne les conna√Æt pas encore ?
Notre application doit √™tre **√©volutive**. Notre code doit avoir la capacit√© d‚Äô√©voluer en impactant le moins possible l‚Äôexistant. Et comment r√©ussir ? Il nous faut **r√©duire les d√©pendances** au sein de notre code

##### Identifiez pourquoi les d√©pendances peuvent √™tre probl√©matiques
> Quel est le probl√®me avec les d√©pendances ? Pourquoi faut-il les r√©duire ?

Illustrons √† l‚Äôaide de l‚Äôexemple d‚Äôun objet Command et d‚Äôun objet Product : mon objet Command n√©cessite un objet Product. Il y a donc une d√©pendance entre les deux.

C‚Äôest l‚Äôobjet Command qui cr√©e l‚Äôobjet Product. Donc si l‚Äôobjet Product est modifi√©, l‚Äôobjet Command doit s‚Äôadapter lui aussi ! Il existe une **d√©pendance forte** entre les 2 objets. Le code suivant illustre cela :
```java
package com.openclassrooms.sb.sample;

public class Command {

    private Product product;

    public Command() {
        this.product = new Product(‚Äúsomething‚Äù);
    }

}
```

Si l‚Äôimpl√©mentation de Product change, alors le constructeur de Command sera impact√©.

Et si on veut utiliser une autre impl√©mentation de la classe Product, √† chaque changement il faudra toucher √† la classe Command.

R√©sultat : bye bye l‚Äô√©volutivit√© ! √Ä l‚Äô√©chelle de centaines, voire de milliers de lignes de code, notre application sera extr√™mement difficile √† maintenir dans le temps ! üôà

##### D√©couvrez la solution : Dependency Injection
Heureusement pour nous, un design pattern existe face √† ce probl√®me : *Dependency Injection*.

> Les design patterns, ou patrons de conception, sont des solutions standard aux probl√©matiques r√©currentes de d√©veloppement.

Rappelons notre probl√©matique : l‚Äôobjet Command a une d√©pendance forte avec l‚Äôobjet Product, car il doit s‚Äôoccuper de sa cr√©ation.

Mais imaginons maintenant que le processus de cr√©ation de l‚Äôobjet Product et son affectation dans l‚Äôobjet Command soient **d√©l√©gu√©s √† une tierce partie**. Voil√† que, par magie (ou presque), l‚Äôobjet Command n‚Äôa plus √† s‚Äôoccuper de l‚Äôobjet Product, et ce dernier ne se pr√©occupe d‚Äôailleurs pas non plus de l‚Äôobjet Command. 

Ce que je viens d‚Äô√©noncer est le principe du **design pattern Dependency Injection** !

Regardons le code :

```java
package com.openclassrooms.sb.sample;

public class Command {

    private Product product;

    public Product getProduct() {
        return product;
    }

    public void setProduct(Product product) {
        this.product = product;
    }

    public Command() { }

}
```

La diff√©rence √† noter est que le *‚Äúnew Product()‚Äù* a disparu. La classe Command ne s‚Äôoccupe plus de l‚Äôinstanciation. C‚Äôest notre fameuse tierce partie qui fera le n√©cessaire, et ins√©rera l‚Äôobjet instanci√© dans l‚Äôobjet Command gr√¢ce √† la m√©thode setProduct(), et cela de fa√ßon transparente.

Finie la d√©pendance forte ! √Ä l‚Äô√©chelle de centaines, voire de milliers de lignes de code, nous obtenons un programme dont les objets peuvent √©voluer bien plus facilement !

##### Impl√©mentez le pattern Dependency Injection avec Spring Framework
> Comment mettre en place cette tierce partie magique ? Dois-je la d√©velopper ?

Non, l‚Äôhiver est pass√©, le printemps est l√† ! Spring Framework s‚Äôoccupe de tout gr√¢ce √† son **IoC container** ! Ce dernier est aussi appel√© le ***contexte Spring***. Il vous permettra de cr√©er des objets dynamiquement, et de les injecter dans d‚Äôautres objets. De plus, on pourra facilement modifier l‚Äôimpl√©mentation d‚Äôun objet, avec quasiment z√©ro impact sur les objets qui utilisent ce dernier.

> IoC est le sigle de *Inversion of Control*. Cette expression indique un principe de programmation qui correspond au fait de d√©l√©guer √† un framework le flux de construction et d‚Äôappels des objets.

Les m√©canismes de l‚Äô**IoC container** rendront **votre code √©volutif, performant et robuste** ! Vous ne serez pas simplement efficace, vous serez efficient ! Durant ce cours, vous aurez l‚Äôoccasion de d√©couvrir comment utiliser le contexte Spring pour b√¢tir de solides applications Java !

#### Soyez plus performant gr√¢ce √† Spring Framework
Parmi nos probl√©matiques en tant que d√©veloppeur, il y a celle d‚Äô√™tre **performant** dans le d√©veloppement de notre projet. Cette performance peut √™tre li√©e au **temps** qu‚Äôon passe √† d√©velopper, mais aussi √† la **qualit√©** du code produit. Et pour cela, Spring Framework nous offre un bel avantage : **la configuration**.

Une des particularit√©s du framework est d‚Äôencourager (voire de forcer) les d√©veloppeurs √† impl√©menter certaines parties du code via de la configuration et non du d√©veloppement.

Prenons un exemple. Pour vous connecter √† une base de donn√©es en Java, vous avez besoin de :
- charger un driver de base de donn√©es (le driver MySQL, par exemple) ;
- cr√©er diff√©rents objets (comme *java.sql.Connection*) ;
- manipuler tous ces objets dans le bon ordre ;
- g√©rer les exceptions, etc. 

Bref, rien que de l‚Äô√©crire, √ßa m‚Äôa fatigu√© !  C‚Äôest pas vraiment complexe, mais c‚Äôest fastidieux !

Mais Spring Framework va nous permettre de r√©soudre tout √ßa en **quelques lignes** ! Non pas en quelques lignes de code, mais de **configuration** ! Pour cela, il nous suffit d‚Äôutiliser les **bons composants Spring** (j‚Äôy reviendrai dans le prochain chapitre) et le bon fichier de configuration :

spring.datasource.url=jdbc:mysql://localhost/test

spring.datasource.username=dbuser

spring.datasource.password=dbpass

spring.datasource.driver-class-name=com.mysql.jdbc.Driver

Voil√†, c‚Äôest r√©gl√© : au sein de l‚ÄôIoC container, tous les objets ont √©t√© cr√©√©s, et on peut interagir avec notre base de donn√©es !

Qu‚Äôen dites-vous ? N‚Äôest-ce pas beaucoup plus performant ? ;-)

Et ce n‚Äôest qu‚Äôun exemple parmi tant d‚Äôautres !

#### D√©couvrez les autres avantages de Spring
Ne partez pas si vite ! Ce n‚Äôest pas fini, Spring Framework est √©galement un **outil tr√®s puissant** car il simplifie certaines actions, indispensables pour r√©pondre √† nos besoins actuels, que nous aurions beaucoup de mal √† r√©aliser par nous-m√™mes. Par exemple :
- Interagir avec une base de donn√©es.
- Traiter des requ√™tes HTTP et √©crire des r√©ponses HTTP.
- Ex√©cuter des traitements par lots (batch).
- G√©rer la s√©curit√© de l‚Äôapplication.
- Etc.

Il ne se limite donc pas √† nous fournir l‚ÄôIoC container, il r√©pond quasiment √† **tous nos besoins techniques**, ce qui augmente aussi notre performance !

> Est-ce vraiment possible qu‚Äôun framework soit si complet ? ü§©

**Oui !** Tout d‚Äôabord car aujourd‚Äôhui une grande part des projets sont des applications construites avec les **technologies web**. Et Spring est tr√®s fort dans ce domaine ! Ensuite, car il est suffisamment ouvert pour permettre d‚Äôinclure d‚Äôautres **librairies** qui seraient n√©cessaires afin de compenser ses manques.

#### En r√©sum√©
- En tant que d√©veloppeurs, nous sommes face √† de nombreuses probl√©matiques : l‚Äô√©volutivit√©, les performances, etc.
- Spring Framework nous offre des **solutions concr√®tes** √† ces probl√©matiques :
    - l‚Äô**IoC container** pour l‚Äôimpl√©mentation du pattern **Dependency Injection** ;
    - la capacit√© de **configurer** plut√¥t que de d√©velopper ;
    - **des composants** pour g√©rer une multitude d‚Äôaspects, comme par exemple interagir avec des bases de donn√©es, ou traiter des requ√™tes HTTP.

### D√©couvrez le framework Spring
Spring est un **framework**, c‚Äôest-√†-dire un **cadre de travail existant** que les d√©veloppeurs peuvent utiliser. Imaginez que vous vouliez r√©am√©nager votre cuisine, allez-vous construire de z√©ro le moindre tuyau, meuble ou accessoire ? ü§î Absolument pas ! Ce serait une perte de temps, et peut-√™tre m√™me de qualit√©. 

La solution ? Direction les magasins sp√©cialis√©s pour acheter le n√©cessaire. Mais attention ! Vous restez responsable de choisir les bons meubles, de les monter, de faire en sorte que tout s‚Äôassemble pour obtenir un r√©sultat final homog√®ne.

Spring Framework, c‚Äôest un peu comme un **grand magasin sp√©cialis√©** : il y a de nombreuses choses √† trouver, et apr√®s, √† nous de faire l‚Äôassemblage. Faisons un tour des rayons ensemble ! üßê

![composantsSpring](/readMeIMG/composantsSpring.png)

#### Spring Core
Ce composant est **la base de l‚Äô√©cosyst√®me** Spring. 

Il contient le **‚Äúcore container‚Äù** (ce qui permet l‚Äôinjection de d√©pendances vue pr√©c√©demment), mais il contient √©galement **Spring MVC** qui permet de faire du web et de Data Access qui fournit des √©l√©ments fondamentaux pour la communication avec les bases de donn√©es.

> Pour avoir tout le d√©tail, suivez la [documentation officielle](https://spring.io/projects/spring-framework) sur Spring Core.

#### Spring Data
Ce composant permet de **communiquer avec de nombreux types de bases de donn√©es**. Par exemple, il offre la capacit√© de communiquer avec une base de donn√©es en impl√©mentant uniquement des interfaces gr√¢ce √† des conventions de nommage : bluffant !

> Pour avoir tout le d√©tail, suivez la [documentation officielle](https://spring.io/projects/spring-data) sur Spring Data.

#### Spring Security
Pensez-vous que la s√©curit√© soit un √©l√©ment essentiel d‚Äôune application ? Moi, oui ! Et des millions de d√©veloppeurs partagent ce point de vue. C‚Äôest pour √ßa que ce composant est l‚Äôun des plus critiques de Spring Framework, bien qu‚Äôil soit aussi l‚Äôun des plus complexes.
Il permet de g√©rer **l‚Äôauthentification**, **l‚Äôautorisation**, mais aussi la **s√©curit√© des API**.

> Pour avoir tout le d√©tail, suivez la [documentation officielle](https://spring.io/projects/spring-security) sur Spring Security. 

#### Spring Cloud
Avez-vous entendu parler de **l‚Äôarchitecture microservice** ? Si ce n‚Äôest pas le cas, ne vous inqui√©tez pas, mais cela va venir tr√®s vite car c‚Äôest le mod√®le d'architecture le plus pris√© actuellement. Et pour r√©pondre aux contraintes de cette architecture logicielle, Spring Framework fournit Spring Cloud. 

> Pour avoir tout le d√©tail, suivez la [documentation officielle](https://spring.io/projects/spring-cloud) sur Spring Cloud.

#### Spring Boot
C‚Äôest un composant tr√®s particulier de Spring Framework, dans la mesure o√π il nous permet de mettre en ≈ìuvre tous les autres. Ce cours vous montrera comment tirer profit de la puissance de Spring Boot, et de ses avantages qui sont :
- l'**autoconfiguration** automatique de Spring ;
- des **starters de d√©pendances** ;
- des **endpoints Actuator** pour fournir des donn√©es sur l‚Äôapplication.

>Pour avoir tout le d√©tail, vous pouvez suivre la [documentation officielle](https://spring.io/projects/spring-boot) sur Spring Boot. 
>
>Et ce n‚Äôest pas tout ! Pour explorer tous les autres projets, vous pouvez vous rendre sur [cette page](https://spring.io/projects).

#### En r√©sum√©
- Spring propose de **nombreux composants** pour r√©pondre aux besoins des d√©veloppeurs !
- L‚Äôun des plus utiles est **Spring Boot**, car il permet de mettre en ≈ìuvre les autres composants de Spring avec facilit√©, notamment gr√¢ce **aux starters de d√©pendances** et √† **l‚Äôautoconfiguration**.

### Identifiez les avantages de Spring Boot

#### Simplifiez votre projet avec Spring Boot
Vous l‚Äôavez not√©, Spring est un √©cosyst√®me avec un grand E ! √Ä tel point que parfois ce framework peut m√™me sembler trop rigide, trop encombrant ou trop complexe, il faut le reconna√Ætre. De plus, il contient de nombreux composants, et ces derniers ne s‚Äôutilisent pas de fa√ßon exclusive : dans la tr√®s grande majorit√© des projets, vous devrez utiliser **plusieurs composants de Spring simultan√©ment**. Par voie de cons√©quence, l‚Äôint√©gration de plusieurs composants Spring pour un m√™me projet ajoute de la complexit√©. **Complexit√© qui sera croissante** plus le projet prendra de l‚Äôimportance !

Non non, ne fuyez pas !üòÖ Rassurez-vous, une solution existe ! Nous pouvons tirer profit de tous les avantages de Spring sans y perdre notre latin !

> Comment faire ? üò±

Je vous en ai d√©j√† bri√®vement parl√© au chapitre pr√©c√©dent, il s‚Äôagit d‚Äôutiliser **Spring Boot** ! Ce composant de Spring a √©t√© cr√©√© pour nous aider √† utiliser Spring Framework. C‚Äôest un composant **au service des autres composants**.

Illustrons l‚Äôid√©e. Vous vous souvenez peut-√™tre de la comparaison que j‚Äôai d√©j√† utilis√©e : Spring Framework est comme un grand magasin sp√©cialis√© de meubles, o√π un composant est tel un meuble que l‚Äôon peut acheter.

Eh bien Spring Boot, c‚Äôest comme des gammes de meubles qui nous sont propos√©es. Lorsqu‚Äôon ach√®te un meuble, il est certain que les autres meubles de la m√™me gamme iront ensemble (c‚Äôest pour √ßa que c‚Äôest une gamme !), et cela √©vite les surprises lors de l‚Äôassociation des meubles.

L√†, c‚Äôest pareil : Spring Boot nous met √† disposition les bons composants, nous permettant ainsi de les faire fonctionner ensemble.

Et cela contribuera √† la **simplification** de notre projet !

#### √Ä vous de jouer !
Jouons au jeu des 7 diff√©rences ! Je vous propose de comparer deux projets Java qui utilisent Spring Framework. L‚Äôun utilise le composant Spring Boot, l‚Äôautre non.

La consigne est simple : **Quelles diff√©rences pouvez-vous observer ?**

Projet **[sans](https://github.com/OpenClassrooms-Student-Center/creez-une-application-spring-boot/tree/master/webwithoutsb)** Spring Boot;

Projet **[avec](https://github.com/OpenClassrooms-Student-Center/creez-une-application-spring-boot/tree/master/webwithsb)** Spring Boot.

Alors, qu‚Äôavez-vous not√© ?

Je vous d√©cris les diff√©rences entre ces deux projets, en mettant en avant les avantages de Spring Boot ‚úÖ.
| **R√©pertoires**    | **Sans Spring Boot**                                         | **Avec Spring Boot**                                         |
| :----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| src/main/java      | 4 classes Java : <br />   1. HomeController.java<br />   2. User.java<br />   3. UserRepository.java<br />   4. **JpaConfig.java** : c‚Äôest moi qui ai cr√©√© cette classe‚Ä¶ üòÖ | 4 classes Java :<br />   1. HomeController.java<br />   2. User.java<br />   3. UserRepository.java<br />   4. **WebwithsbApplication.java** : c‚Äôest une classe cr√©√©e automatiquement par Spring Boot, plus de perte de temps ! ‚úÖ |
| src/main/resources | - **contextFront.xml** : configuration manuelle du scanning et du viewresolver<br /> - **META-INFO/persistence.xml** : contient la configuration de la BDD | - **Pas besoin de contextFront** : Spring Boot s‚Äôen occupe ! ‚úÖ<br /> - **application.properties** : contient la configuration de la BDD. Est plus simple √† aborder que XML. <br /> - ‚úÖ**template/home.html** : rendu HTML √† fournir. |
| src/main/webapp    | **2 fichiers** :<br /> - **template/home.jsp** : rendu HTML √† fournir<br /> - **web.xml** : fournit de la configuration pour la gestion des servlets | Ce dossier **n‚Äôexiste pas** ! Spring Boot n‚Äôa pas besoin de tout √ßa ! ‚úÖ |
| fichiers pom.xml   | **8** d√©pendances<br />+ **2** d√©pendances dans le dependencyManagement pour les versions | **5** d√©pendances **sans avoir d√©fini les versions**         |

üëâ Moins de fichiers, plus d‚Äôautomatisation‚Ä¶ Bref, c‚Äôest une victoire tr√®s nette de Spring Boot, qui nous simplifie la vie !

Et cerise sur le g√¢teau : pour le d√©ploiement, le projet avec Spring Boot se lance avec une simple commande, alors que le projet sans Spring Boot me demande d‚Äôinstaller un serveur web (comme Tomcat) pour le d√©ployer et le d√©marrer.

Vraiment, jusqu‚Äôau bout, Spring Boot nous simplifie les choses ! ü§©

#### Les avantages de Spring Boot
Reprenons notre souffle apr√®s cet exercice, et analysons les avantages de Spring Boot.

##### Avantage n¬∞ 1 : optimisation de la gestion des d√©pendances
Spring Boot nous fournit des **starters**, qui correspondent √† un ensemble de d√©pendances homog√©n√©is√©es (associations, versions). On peut les comparer √† des **kits de d√©pendances**.
[Les Starters](https://user.oc-static.com/upload/2020/11/10/1605004979024_image3.png)

Nul besoin de d√©finir les versions des d√©pendances explicitement dans le pom.xml : Maven les d√©duit gr√¢ce √† la version de Spring Boot utilis√©e.

Dans ce cours, nous allons apprendre √† choisir les bons starters en fonction du besoin.

##### Avantage n¬∞ 2 : l‚Äôautoconfiguration
C‚Äôest peut-√™tre l‚Äôavantage le plus important de Spring Boot ! L‚Äôexercice pr√©c√©dent l‚Äôa r√©v√©l√© : avec Spring Boot, il y a beaucoup moins de configuration (concernant la gestion des servlets, le chargement du contexte Spring, la connexion √† la base de donn√©es). Ce n‚Äôest pas un hasard. L‚Äôutilisation de Spring Boot, et l‚Äôannotation @SpringBootApplication plac√©e au niveau de la classe principale de notre projet (celle g√©n√©r√©e automatiquement), d√©clenchent automatiquement de nombreuses op√©rations en background qui nous sont n√©cessaires.

Le d√©veloppeur peut alors **se concentrer sur le code m√©tier** au lieu de passer un temps fou √† configurer le framework qu‚Äôil utilise.

Au fur et √† mesure du cours, je vous en dirai plus sur les op√©rations que Spring Boot r√©alise en background.

##### Avantage n¬∞ 3 : la gestion des propri√©t√©s
Spring Boot permet de **g√©rer les propri√©t√©s au sein d‚Äôun programme en toute simplicit√©**.

Dans l‚Äôexercice, vous avez pu voir le fichier **applications.properties**. Les informations qui √©taient saisies ont √©t√© prises en compte par certaines classes, sans que nous ayons besoin d‚Äôagir. Ce fichier est **l‚Äôun des √©l√©ments cl√©s** pour la gestion des propri√©t√©s de notre programme.

Mais cela ne se limite pas √† ce simple fichier ; par exemple, il est facilement possible de r√©cup√©rer m√™me des variables d‚Äôenvironnement syst√®me, et de les fournir √† nos classes.

Dans ce cours, nous d√©couvrirons comment tirer profit de la capacit√© de Spring Boot √† g√©rer les propri√©t√©s.

##### Avantage n¬∞ 4 : le monitoring et la gestion du programme
Je ne souhaite pas rentrer dans le d√©tail ici, mais sachez que **Spring Boot Actuator** correspond √† une fonctionnalit√© de Spring Boot qui permet de **monitorer et de manager notre programme** pendant qu‚Äôil est en cours d‚Äôex√©cution.

Par exemple, gr√¢ce aux **endpoints Actuator**, on peut modifier une propri√©t√© en live, et le programme en tiendra compte sans qu‚Äôon ait besoin de le red√©marrer. Tr√®s utile !

##### Avantage n¬∞ 5 : le d√©ploiement
Quel est l‚Äôartefact produit par un projet Spring Boot ? Un simple fichier JAR. 

Que faut-il pour ex√©cuter un JAR ? Vous le savez, une JRE, et c‚Äôest tout !
> Mais comment est-ce possible pour une application web qui a forc√©ment besoin d‚Äôun serveur de conteneur web ?

Un projet Spring Boot contient un tomcat embarqu√© au sein m√™me du JAR g√©n√©r√©. Le projet web peut donc √™tre d√©ploy√© au sein de ce tomcat embarqu√©.

Conclusion, ex√©cuter notre projet Spring Boot, quelles que soient ses fonctionnalit√©s, est tr√®s simple ! Et cela permet de coupler facilement nos projets Spring Boot avec d‚Äôautres outils comme Docker.

#### En r√©sum√©
- Spring Boot ≈ìuvre pour la **simplification** du d√©veloppement de nos projets avec Spring Framework.
- La gestion des d√©pendances est simplifi√©e gr√¢ce aux **starters** qui **regroupent plusieurs d√©pendances** et **homog√©n√©isent les versions**.
- L‚Äô**autoconfiguration** permet de **se concentrer sur le code m√©tier**, et simplifie √©norm√©ment la mise en ≈ìuvre des composants Spring qui sont utilis√©s.
- La gestion efficace des propri√©t√©s rend notre application **configurable**.
- Spring Boot **Actuator** permet de **monitorer** et **g√©rer** une application **pendant son ex√©cution**.
- Le d√©ploiement de l‚Äôapplication est facilit√© par la g√©n√©ration d‚Äôun JAR, et pour les projets web, un **tomcat est embarqu√©**.

## Partie 2 - D√©couvrez les √©tapes cl√©s de tout projet Spring Boot

### Cr√©ez votre projet
Dans cette partie de cours, nous allons ensemble d√©couvrir les √©tapes cl√©s pour tout projet Spring Boot. Cette partie est construite comme une sorte de mode d‚Äôemploi, auquel vous pouvez vous r√©f√©rer quelle que soit l‚Äôapplication que vous r√©alisez !

Cr√©ons ensemble le fameux **‚ÄúHello World‚Äù** avec Spring Boot !

Tout d‚Äôabord, voici le plan d‚Äôaction pour tout projet Spring Boot :
1. Cr√©er le projet, c‚Äôest-√†-dire g√©n√©rer la structure minimale.
2. Structurer et configurer le projet.
3. √âcrire le code.
4. Tester et d√©ployer.

Chaque √©tape du plan d‚Äôaction correspond √† un chapitre de cette partie du cours. Et les 2 parties de cours suivantes sont construites sur la base des m√™mes √©tapes.

C‚Äôest parti pour la premi√®re √©tape : **cr√©ons notre projet !** üòé

#### D√©couvrez les starters
> On commence par quoi ?

La premi√®re √©tape implique de g√©n√©rer la base de votre projet. Vous devez savoir qu‚Äôon ne commence pas sur une feuille blanche. Spring Boot nous fournit une base de travail que l‚Äôon peut nommer la **structure minimale**. On enrichira ensuite cette structure minimale en fonction des besoins de notre projet.

Pour obtenir cette structure minimale, il y a plusieurs solutions que l‚Äôon explorera dans la suite du chapitre. Mais avant de foncer t√™te baiss√©e, sachez que Spring Boot va vous demander un certain nombre d‚Äôinformations, comme :
- la version de Java ;
- Maven ou Gradle ;
- la version de Spring Boot ;
- des informations sur le projet (groupId, artifactId, nom du package) ;
- les d√©pendances.

Pour les premiers √©l√©ments, ce ne sera pas difficile ; √ßa pourrait par contre le devenir pour le choix des d√©pendances, car Spring Boot utilise quelque chose de nouveau : **les starters de d√©pendances**.

J‚Äôai d√©j√† eu l‚Äôoccasion dans la partie pr√©c√©dente de vous en parler, mais un rappel ne fera pas de mal.

Spring Framework se d√©coupe en de nombreux composants ; les utiliser implique de renseigner les bonnes d√©pendances pour notre projet. Ce n‚Äôest pas facile, car il faut savoir quelle d√©pendance est n√©cessaire √† quelle autre d√©pendance, s‚Äôil y a des incompatibilit√©s, et quelles sont les versions √† utiliser.

Pour r√©soudre cette probl√©matique, Spring Boot nous offre les starters de d√©pendances qui sont des kits de d√©pendances (vous vous souvenez de mon exemple avec les gammes de meubles, voil√† !  ).

Par exemple, le starter **spring-boot-starter-data-jpa** va vous apporter diff√©rents JAR pour utiliser Spring et JPA, afin de communiquer avec une base de donn√©es.

Tous les starters sont pr√©fix√©s par ‚Äúspring-boot-starter‚Äù. Voici quelques exemples de starters :
- spring-boot-starter-core ;
- spring-boot-starter-data-jpa ;
- spring-boot-starter-security ;
- spring-boot-starter-test ;
- spring-boot-starter-web.

> Comment choisir les bons starters pour mon projet ?

Normalement, la **description du starter** est suffisante pour identifier si ce dernier est ce dont vous avez besoin ou non. Sans oublier que la documentation officielle de Spring saura toujours vous guider vers le bon starter en fonction de vos besoins.

Il n‚Äôy rien de plus √† savoir sur la question, je crois qu‚Äôil est temps de pratiquer !

Il existe deux fa√ßons de cr√©er un projet : avec Spring Initializr et avec Spring Tool suite. Nous allons aborder ces deux approches ensemble !

#### Cr√©ez votre projet avec Spring Initializr

Voyons comment utiliser le site web [Spring Initializr](https://start.spring.io/).

R√©capitulons les √©tapes :
1. J‚Äôai laiss√© par d√©faut Project / Language et Spring Boot.
2. J‚Äôai saisi les informations suivantes dans Project Metadata :
   - Group: com.openclassrooms.
   - Artifact: HelloWorld.
   - Name: HelloWorld.
   - Description: Hello World project with Spring Boot.
   - Package name: com.openclassrooms.helloworld.
   - Packaging: Jar.
   - Java: 8.

Aucune d√©pendance √† ajouter, car le starter ‚Äú**spring-boot-starter**‚Äù, qui contient toutes les fonctionnalit√©s de base, est ajout√© par d√©faut. J‚Äôai cliqu√© sur ‚ÄúGenerate‚Äù, et une archive ZIP avec le projet a √©t√© t√©l√©charg√©e. Apr√®s avoir d√©zipp√© l‚Äôarchive, j‚Äôai tout simplement import√© ce projet existant dans mon IDE.

Voil√†, notre premi√®re √©tape est finie ! 

#### Cr√©ez votre projet avec Spring Tool Suite
Une deuxi√®me fa√ßon d'atteindre le m√™me r√©sultat correspond √† l‚Äôutilisation de l‚Äôoutil Spring Tool Suite, t√©l√©chargeable [ici](https://spring.io/tools).

Je vous conseille **Spring Tools 4 for Eclipse**. Il est t√©l√©chargeable sur Linux, macOS et Windows. Vous obtenez un JAR qui, une fois ex√©cut√©, va cr√©er un r√©pertoire qui aura un nom du style ‚Äústs-4.7.1.RELEASE‚Äù. Au sein de ce r√©pertoire, vous pouvez lancer l‚Äôex√©cutable ‚ÄúSpringToolSuite4.exe‚Äù.

> Spring Tools 4 for Eclipse est un outil d√©velopp√© sur la base de l‚ÄôIDE Eclipse. Les habitu√©s de cet IDE ne seront donc pas d√©pays√©s !

Avez-vous remarqu√© qu‚Äôon retrouve les m√™mes √©tapes, mais cette fois √† travers un outil install√© sur votre poste de travail, et non via un site web ?

> Mais pourquoi utiliser Spring Tool Suite et non Spring Initializr, qui ne demande aucun outil suppl√©mentaire ?

Pour la simple raison que STS (Spring Tool Suite) nous offre une fonctionnalit√© suppl√©mentaire : le ‚Äú**Boot Dashboard**‚Äù, qui permet de g√©rer plus pr√©cis√©ment le **cycle de vie de l‚Äôex√©cution de l‚Äôapplication**. Et comme STS est tout simplement un Eclipse customis√©, on peut directement d√©velopper notre projet au sein de l‚Äôoutil. Assez pratique, finalement. 

Pour finir cette partie, je vous encourage √† jeter un ≈ìil au fichier pom.xml (√† la racine de la structure du projet). Vous y retrouverez tous les √©l√©ments saisis lors de la g√©n√©ration de votre projet. En voici d‚Äôailleurs 2 extraits :

Extrait de la description du projet :
```java
<groupId>com.openclassrooms</groupId>
<artifactId>helloworld</artifactId>
<version>0.0.1-SNAPSHOT</version>
<name>helloworld</name>
<description>Hello World project with Spring Boot</description>
```

Extrait des d√©pendances du projet :
```java
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>
    ‚Ä¶.
</dependencies>
```

#### En r√©sum√©
- La premi√®re √©tape pour utiliser Spring Boot est de **cr√©er la structure minimale**.
- On obtient la structure minimale en fournissant plusieurs informations, dont **les starters de d√©pendances**.
- Un projet Spring Boot peut √™tre cr√©√© via **Spring Initializr** ou bien via **Spring Tool Suite**.

### Observez la structure minimale
#### Explorez la structure minimale
Voici le projet √† travers la vue Package Explorer de STS. Qu'observez-vous? Comment les sources sont-elles organis√©es ?

Voici quelques points √† noter :
- Nous retrouvons les fichiers li√©s √† Maven (pom.xml, mvnw et mvnw.cmd).
- Nos sources sont organis√©es suivant le sch√©ma standard :
    - src/main/java : contient les packages et les classes Java ;
    - src/main/resources : contient les fichiers ressources, tels que les fichiers de propri√©t√©s ou des templates (HTML, par exemple) ;
    - src/test/java : contient les classes Java de test.
- Comme tout projet Java/Maven, on retrouve √©galement la JRE et les Maven Dependencies.

J‚Äôattire √©galement votre attention sur le fait que cette structure minimale ne contient pas que des r√©pertoires et des packages : il y a aussi deux classes Java et un fichier Propri√©t√©s.

Le fichier de propri√©t√©s ‚Äúapplication.properties‚Äù est cr√©√© par d√©faut, mais il est vide ; j‚Äôy reviendrai plus tard, promis !

Pour ce qui de la classe HelloWorldApplicationTests.java, je ne souhaite pas m‚Äôy arr√™ter non plus √† cette √©tape ; sachez juste pour le moment qu‚Äôelle v√©rifie que le contexte Spring se lance bien comme attendu.

Maintenant, parlons de HelloWorldApplication.java, qui est la **classe principale** de votre projet. On y retrouve 2 choses importantes :
1. La m√©thode main dont je ne vous ferai pas l‚Äôoffense de vous expliquer son r√¥le en Java !
2. L‚Äôannotation @SpringBootApplication qui est critique !

> S T O P ! Annotation, tu dis ?

Vous avez raison, je vais vous expliquer ce qu‚Äôest une annotation, et son utilit√© au sein de Spring.

#### D√©couvrez le r√¥le des annotations et leurs avantages
Nous avons vu ensemble que Spring Framework fournit l‚ÄôIoC container, dans la partie 1 du cours. L‚ÄôIoC container va instancier pour vous des classes, puis si n√©cessaire les injecter dans d‚Äôautres instances de classe. Pour qu‚Äôune classe soit manipul√©e par l‚ÄôIoC container, **il est n√©cessaire de l‚Äôindiquer explicitement √† Spring**. Comment ?

La premi√®re solution est l‚Äôutilisation de **fichiers XML** au sein desquels on d√©crit les classes que Spring doit g√©rer ; voici un exemple des plus simples :
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
    "http://www.springframework.org/dtd/spring-beans-2.0.dtd">

<beans>
    <bean id="myBean" class="com.openclassrooms.BeanImpl"/>
</beans>
```

La classe com.openclassrooms.BeanImpl (qui a √©t√© cr√©√©e pr√©alablement, √©videmment) sera ainsi prise en compte par l‚ÄôIoC container.

> Cette solution est l‚Äôune des plus anciennes fa√ßons de faire. Aujourd‚Äôhui, elle est de moins en moins utilis√©e, de par sa complexit√©.

La seconde solution est l‚Äôutilisation des annotations.

Une annotation, c‚Äôest-√†-dire **@[nom de l‚Äôannotation]**, peut √™tre ajout√©e √† une classe, une m√©thode, un attribut. **L‚Äôannotation influe sur le comportement du programme** car elle fournit des m√©tadonn√©es lors de la compilation ; ces m√™mes m√©tadonn√©es seront utilis√©es lors de l‚Äôex√©cution.

Depuis la version 2.5 de Spring, de nombreuses annotations sont fournies, dont le but est de :
1. Permettre √† l‚ÄôIoC container d‚Äô**utiliser nos classes**.
2. **Influer sur le comportement** de Spring.

Voici quelques exemples d‚Äôannotations Spring :
- @Component
- @Autowired
- @Qualifier

> Il n‚Äôy a pas que Spring qui utilise les annotations. Il en existe au sein m√™me de Java, et d‚Äôautres frameworks utilisent aussi ce puissant outil.

Si on reprend l‚Äôexemple pr√©c√©dent, voici la correspondance en annotation :
```java
package com.openclassrooms;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
@Qualifier(‚ÄúmyBean‚Äù)
public class BeanImpl {
    // TO DO
}
```

L‚Äôannotation @Component permet de d√©clarer la classe BeanImpl aupr√®s de Spring, comme √©tant un bean √† avoir dans l‚ÄôIoC container.

L‚Äôannotation @Qualifier permet de donner un nom √† ce bean, en l'occurrence ‚ÄúmyBean‚Äù (si cette annotation n‚Äôest pas d√©finie, le nom par d√©faut est le nom de la classe).

Qu‚Äôen dites-vous ? C‚Äôest plus sympa, non ? Nul besoin de manipuler du XML, tout se passe dans le Java !

> En r√©alit√©, il n‚Äôy a pas vraiment une meilleure fa√ßon de faire, les 2 sont valides. La configuration via XML est la fa√ßon historique de faire, et on la retrouve encore sur de nombreux projets. Tandis que la configuration par annotations est ce qui s‚Äôutilise de plus en plus, notamment par la d√©mocratisation de Spring Boot.

#### Utilisez l‚Äôannotation @SpringBootApplication
Revenons maintenant √† nos moutons ! Ou plut√¥t √† **l‚Äôannotation @SpringBootApplication**. √Ä quoi sert-elle ?

Comme je vous l‚Äôai expliqu√©, elle va permettre √† l‚ÄôIoC container de manipuler la classe HelloWorldApplication.java. Elle permettra √©galement d‚Äôinfluer sur le comportement de Spring.

@SpringBootApplication est un compos√© de 3 autres annotations :
1. **@SpringBootConfiguration** : la classe sera utilis√©e comme une classe de configuration (on reviendra sur cette notion plus tard).
2. **@EnableAutoConfiguration** : active la fameuse fonctionnalit√© d‚Äôautoconfiguration de Spring Boot, que je vous ai tant vant√©e.
3. **@ComponentScan** : active le ‚Äú**scanning**‚Äù de classes dans le package de la classe et dans ses sous-packages. Sans cette annotation, l‚ÄôIoC container ne tiendra pas compte de vos classes, m√™me si vous avez ajout√© une annotation sur celles-ci. 

OK, on y voit plus clair maintenant ! **En r√©sum√©, cette classe, c‚Äôest ce qui d√©clenche toute la m√©canique interne de Spring Boot et des composants Spring associ√©s**. Et tout √ßa en moins de 15 lignes de code.

Nous voil√† au bout de l‚Äôanalyse de la structure minimale d‚Äôun projet Spring Boot, et quelle conclusion tirons-nous ?

Oui, nous avons une base, c‚Äôest vrai, mais il y a des trous !
1. Au sein de src/main/java, nous avons **un seul package**. Et vu qu‚Äôun d√©veloppeur apprend √† regrouper les classes par sous-ensemble, nous allons devoir **cr√©er des sous-packages** pour nos diff√©rentes classes √† venir.
2. Le fichier applications.properties est vide ! Le pauvre, il doit se sentir bien inutile... Rassurez-vous, on va vite lui donner un r√¥le √† jouer !

Remplissons ces trous pour pouvoir aller de l‚Äôavant !

#### En r√©sum√©
- La structure minimale n‚Äôest pas suffisante, il faut l‚Äôenrichir.
- Les **annotations sont un pilier** au sein de Spring Boot pour tirer profit de l‚ÄôIoC container.
- L‚Äôannotation **@SpringBootApplication** est la concat√©nation de plusieurs annotations, et son objectif est de d√©clencher toute la m√©canique interne de Spring.

### Structurez et configurez votre projet
#### Structurez vos packages
> Comment structurer notre package si on ne conna√Æt pas encore les classes qui seront produites ?

Bonne question, je vois que vous √™tes r√©fl√©chi et que vous avez appris √† ne pas foncer t√™te baiss√©e ! Bravo !

La r√©ponse se veut tr√®s simple : **les bonnes pratiques** !

Premi√®rement, gardons √† l‚Äôesprit que Spring Boot est particuli√®rement utilis√© dans le contexte d‚Äôapplication web (m√™me si √ßa ne se limite pas √† cela).

Deuxi√®mement, la majorit√© des applications ont la n√©cessit√© d'interagir avec des donn√©es externes (par exemple une base de donn√©es, un autre programme, ou m√™me le syst√®me de fichiers).

De ces diff√©rents besoins, une architecture en couches a √©merg√©, avec un r√¥le pour chaque couche :
- **couche Controller** : gestion des interactions entre l‚Äôutilisateur de l‚Äôapplication et l‚Äôapplication ;
- **couche Service** : impl√©mentation des traitements m√©tiers sp√©cifiques √† l‚Äôapplication ;
- **couche Repository** : interaction avec les sources de donn√©es externes ;
- **couche Model** : impl√©mentation des objets m√©tiers qui seront manipul√©s par les autres couches.

[Repr√©sentation visuelle de l'architecture en couches](https://user.oc-static.com/upload/2020/11/10/1605015466847_image11.png)

Cette architecture standard correspondra √† la majorit√© de vos projets, et vous la retrouvez tr√®s fr√©quemment.

> D‚Äôautres packages peuvent √™tre parfois n√©cessaires, par exemple un nomm√© ‚Äúsecurity‚Äù pour les classes d√©di√©es √† la s√©curit√©, ou ‚Äúconfiguration‚Äù pour des classes g√©rant les propri√©t√©s. Dans ce cas, cela s'ajoute √† la structure existante.

Pour √™tre franc, on n'a pas besoin de tous ces packages pour un simple Hello World. Mais dans les parties du cours suivantes, vous les verrez en action.

Dans notre cas, contentons-nous de cr√©er les packages service et model.

#### Compl√©tez le fichier applications.properties
L‚Äô√©tape suivante consiste √† d√©finir quelques informations de base pour notre application, √† travers les propri√©t√©s.

Mais avant, laissez-moi vous en apprendre un peu plus sur Spring et la gestion des propri√©t√©s. Je ne vous apprends rien en vous disant qu‚Äôune application doit √™tre **param√©trable**, c‚Äôest-√†-dire que son comportement peut changer en fonction des param√®tres fournis.

Pour rendre param√©trable une application, elle doit donc √™tre capable de lire ces param√®tres. Mais o√π sont-ils ? Qui les d√©finit ? Comment les lire ?

Ils sont dans des ‚Äú**sources de propri√©t√©s**‚Äù (property sources), et sont d√©finis par les gestionnaires de ces sources.

L√† o√π Spring Boot nous int√©resse, c‚Äôest qu‚Äôil est capable de lire ces sources de propri√©t√©s (sans interaction de notre part), et de rendre les propri√©t√©s disponibles sous forme de beans au sein du contexte Spring.

Parmi les sources de propri√©t√©s, il y a :
- les propri√©t√©s de la JVM ;
- les variables d‚Äôenvironnements du syst√®me d‚Äôexploitation ;
- les arguments pass√©s par la ligne de commande ;
- les fichiers .properties ou .yml (comme *application.properties*).

Vous aurez l‚Äôoccasion de manipuler ces diff√©rentes sources de propri√©t√©s, mais pour le Hello World, on va se contenter de rajouter quelques informations au fichier applications.properties.

> Comment fait-on pour conna√Ætre les propri√©t√©s existantes, vu que application.properties est vide ?

Pour en savoir plus sur les propri√©t√©s de Spring, vous pouvez lire la [documentation de Spring](https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html).

D‚Äôaccord, je vous aide, mettons en place 2 propri√©t√©s :
1. spring.application.name : permet de donner un nom √† notre application Spring Boot.
2. logging.level.[package] : permet d‚Äôindiquer le log level pour un package donn√©.

> Besoin d‚Äôen savoir plus sur les loggers ? Vous pouvez suivre le cours ‚ÄúD√©buggez votre application Java‚Äù, et particuli√®rement le chapitre [‚ÄúFaites des rapports avec un logger, des niveaux de log, et l‚ÄôAPI SLF4J standard‚Äù](https://openclassrooms.com/fr/courses/6692416-debuggez-votre-application-java/6915582-faites-des-rapports-avec-un-logger-des-niveaux-de-log-et-l-api-slf4j-standard).

Voil√† le r√©sultat de mon fichier applications.properties :
```java
spring.application.name=HelloWorld

logging.level.org.springframework=error
```

Quelques explications :
- Ici, le nom est arbitraire ; √† vrai dire, cela n‚Äôaura pas d‚Äôimpact sur le d√©roulement de l‚Äôapplication pour notre Hello World, c‚Äôest surtout informatif. 
- `logging.level.org.springframework=ERROR` : les classes du package org.springframework affichent uniquement les logs de niveau ERROR dans la console (autrement dit, on n‚Äôest pas pollu√© par plein d‚Äôinformations).

C‚Äôest tout ! Nous n‚Äôavons rien √† faire d‚Äôautre, car dans le monde magique de Spring Boot, les propri√©t√©s sont prises en compte automatiquement sans que le d√©veloppeur ait d‚Äôautres actions √† r√©aliser !

#### En r√©sum√©
- Je vous conseille de suivre les bonnes pratiques pour structurer vos packages, et de suivre **un mod√®le en couches**.
    - En l‚Äôoccurrence, nous avons opt√© pour 4 couches : Controller, Service, Repository et Model.
    - L‚Äôapproche en couches permet une meilleure √©volution et une meilleure maintenabilit√© du code.
- Spring Boot a la tr√®s grande capacit√© de savoir lire des **sources de propri√©t√©s**, et le fichier applications.properties en est la d√©monstration. Pour configurer rapidement et efficacement votre application, ajoutez vos propri√©t√©s au fichier applications.properties.

### √âcrivez votre premier Hello World
#### Identifiez o√π et comment √©crire votre code
Le moment tant attendu pour nous d√©veloppeurs est arriv√© ! Nous allons **C-O-D-E-R** !

Pour rappel, nous avons cr√©√© notre projet, puis nous l‚Äôavons structur√© et configur√©. Nous sommes maintenant √† l‚Äô√©tape 3 : nous allons √©crire le code m√©tier, c‚Äôest-√†-dire les traitements fonctionnels attendus. Pour r√©ussir cette √©tape, nous allons devoir nous concentrer sur les beans que Spring doit g√©rer.

> Pour rappel, un **bean est une classe au sein du contexte Spring** (l‚ÄôIoC container).

> Quels sont les besoins fonctionnels pour notre application HelloWorld ?

Rien de plus simple, afficher le texte ‚ÄúHello World!‚Äù dans la console.

> De quoi avons-nous besoin pour atteindre cet objectif ?

**Savoir √©crire dans la console !**

En Java, pour afficher du texte dans la console, la fonction **System.out.println()** permet de le faire. Mais o√π va-t-on placer notre code ?

Reprenons notre classe principale :
```java
package com.test.helloworld;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class HelloworldApplication {

	public static void main(String[] args) {
		SpringApplication.run(HelloworldApplication.class, args);
	}

}
```

La m√©thode main sera th√©oriquement l√† o√π on √©crirait notre code dans un programme Java simple. Mais en l'occurrence, cette derni√®re contient l‚Äôinstruction  `SpringApplication.run(HelloWorldApplication.class, args);`. Cette instruction permet de d√©marrer notre application, et ce n‚Äôest pas une bonne pratique d‚Äôajouter autre chose dans la m√©thode main.

> Oui, mais o√π met-on notre code, alors ?

Spring Boot fournit une interface nomm√©e ‚Äú**CommandLineRunner**‚Äù. En impl√©mentant cette interface, la classe sera oblig√©e de d√©clarer la m√©thode `public void run(String... args) throws Exception`. √Ä partir de l√†, si la classe est un bean (c‚Äôest-√†-dire charg√©e dans le contexte Spring), Spring Boot ex√©cutera la m√©thode run √† l‚Äôex√©cution du programme.

Vous pourriez :
- soit modifier la classe HelloWorldApplication afin qu‚Äôelle impl√©mente CommandLineRunner et la m√©thode run, avec comme corps de m√©thode un ‚ÄúSystem.out.prinln(‚ÄúHello World!‚Äù)‚Äù ;
- soit cr√©er une nouvelle classe qui impl√©mente CommandLineRunner, la m√©thode run (m√™me corps de m√©thode), et qui aura une annotation @Component (au-dessus du nom de la classe).

#### √Ä vous de jouer
Je vous laisse la main, essayez d‚Äôimpl√©menter votre premier HelloWorld !

Pour tester le r√©sultat, si vous utilisez STS via le Boot dashboard, vous pouvez d√©marrer l‚Äôapplication.

Commencez par builder votre application via Maven :
- clic droit sur le nom du projet dans Package Explorer ;
- Run as ;
- Maven install.

Puis lancez l‚Äôapplication via le Boot dashboard :
- sous local, s√©lectionnez votre projet HelloWorld ;
- cliquez sur la premi√®re ic√¥ne du menu.

Voici une solution que je vous propose :
```java
package com.test.helloworld;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class HelloworldApplication implements CommandLineRunner {

	public static void main(String[] args) {
		SpringApplication.run(HelloworldApplication.class, args);
	}
	
	public void run(String... args) throws Exception{
		System.out.println("Hello World!");
	}

}
```

#### Manipulez les beans
> Et les packages service et model, √† quoi servent-ils ?

Nous ne nous sommes pas servi de ces packages car ils n‚Äô√©taient pas utiles pour notre premier Hello World, mais ils le seront pour la suite ! √Ä titre d'entra√Ænement et pour vous faire d√©couvrir d‚Äôautres notions importantes, je vous propose d‚Äô√©crire quelques classes suppl√©mentaires :
- une classe **HelloWorld.java** qui contient un attribut nomm√© **value** de type **String**. Cette classe fait office d‚Äôobjet m√©tier, et doit √™tre dans le **package model**. L‚Äôattribut value doit contenir **le texte ‚ÄúHello World!‚Äù**. On ajoute √©galement une m√©thode **toString** √† cette classe, qui doit retourner le contenu de l‚Äôattribut value ;
- une classe **BusinessService.java** qui contient une m√©thode dont le prototype est ‚Äú**public HelloWorld getHelloWorld()**‚Äù. Cette m√©thode doit instancier un objet HelloWorld, et le retourner. Attention, la classe BusinessService.java doit √™tre d√©clar√©e **en tant que bean dans le context Spring**. J‚Äôen appelle √† votre m√©moire : comment fait-on ?! Via une annotation, bien s√ªr : **@Component** fera l‚Äôaffaire.

Modifions √©galement du code existant :
- La classe HelloWorldApplication doit √™tre compl√©t√©e par un nouvel attribut : ‚Äú**private BusinessService bs;**‚Äù. Ce dernier sera annot√©** @Autowired**.
- Ensuite, la m√©thode run doit √™tre modifi√©e afin qu‚Äôelle contienne le code suivant :
```java
HelloWorld hw = bs.getHelloWorld();
System.out.println(hw);
```

Tout d‚Äôabord, on r√©cup√®re un objet HelloWorld gr√¢ce au BusinessService, puis on transmet l‚Äôobjet HelloWord √† la m√©thode System.out.println. Lors de l‚Äôex√©cution de cette derni√®re, la m√©thode toString() de l‚Äôobjet HelloWorld sera appel√©e, et le texte contenu dans l‚Äôattribut value s‚Äôaffichera.

> Quelque chose m‚Äô√©chappe, l‚Äôattribut bs n‚Äôest jamais instanci√© dans ce code ; comment se fait-il qu‚Äôon puisse l‚Äôutiliser ?

C‚Äôest gr√¢ce √† l‚ÄôIoC container de Spring ! Rappelez-vous, je vous ai appris dans la premi√®re partie le concept de **l‚Äôinjection de d√©pendances**. En mettant l‚Äôannotation @Autowired sur l‚Äôattribut bs, **Spring va chercher au sein de son contexte s‚Äôil existe un bean de type BusinessService**. 

‚úÖ S‚Äôil le trouve, il va alors instancier la classe de ce bean et **injecter cette instance dans l‚Äôattribut**. 

‚ùå S‚Äôil ne trouve pas de bean de ce type, Spring g√©n√®re une erreur.

R√©sultat : nul besoin de g√©rer l‚Äôinstanciation du BusinessService, Spring s‚Äôen occupe pour nous. :-)

#### En r√©sum√©
- Au sein d‚Äôune application Spring Boot, √©crire du code implique de **d√©finir les beans** utilis√©s par Spring.
- On peut ex√©cuter du code gr√¢ce √† l‚Äôimpl√©mentation de l‚Äôinterface **CommandLineRunner** et de la m√©thode **run**.
- Pour qu‚Äôune classe soit **d√©clar√©e en tant que bean**, on l‚Äôannote **@Component**.
- Pour qu‚Äôun bean **soit inject√©** dans un attribut, on annote l‚Äôattribut **@Autowired**.

### D√©couvrez Spring Boot Test et d√©ployez votre projet
#### Abordez la derni√®re √©tape : les tests et le d√©ploiement
C‚Äôest ici la derni√®re ligne droite, et je sens l‚Äôadr√©naline monter! üòÉ

Pour conclure notre application HelloWorld, il nous reste 2 choses √† faire :
1. Tester notre application.
2. D√©ployer notre application.

Pas besoin de vous expliquer que les tests sont utiles, je suis convaincu que vous avez d√©j√† conscience de leur importance.

> Si vous n‚Äô√™tes pas √† l‚Äôaise avec les tests en Java, je vous conseille d‚Äôaller regarder le cours [Testez votre code Java pour r√©aliser des applications de qualit√©](https://openclassrooms.com/fr/courses/6100311-testez-votre-code-java-pour-realiser-des-applications-de-qualite).

‚ÄúD√©ployer‚Äù revient √† mettre en route notre application. Autrement dit, il s‚Äôagit de **passer de l‚Äôenvironnement de d√©veloppement √† l‚Äôenvironnement de production**.

Voyons tout √ßa dans le d√©tail, c‚Äôest parti !

#### D√©couvrez Spring Boot Test
Je vous en ai parl√© pr√©c√©demment, lors de la cr√©ation de la structure minimale du projet, une classe de test a √©t√© cr√©√©e, √† savoir **HelloWorldApplicationTests.java**. Allons la regarder de plus pr√®s ;-) !
```java
package com.openclassrooms.helloworld;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class HelloworldApplicationTests {

    @Test
    void contextLoads() { }

}
```

Plut√¥t simple, n‚Äôest-ce pas ? Presque √©tonnant, d‚Äôailleurs ! Expliquons.

**@SpringBootTest** est une annotation fournie par Spring Boot. Elle permet **lors de l‚Äôex√©cution des tests d‚Äôinitialiser le contexte Spring**. Les beans de notre application peuvent alors √™tre utilis√©s.

Rappelons qu‚Äôun test s‚Äôex√©cute de fa√ßon unitaire, presque comme une application √† part enti√®re. Par d√©faut, notre test n‚Äôa donc aucune connaissance du contexte Spring. Dans le cas d‚Äôune application Spring Boot, c‚Äôest un vrai probl√®me !

Mais le probl√®me est r√©solu gr√¢ce √† l‚Äôannotation @SpringBootTest.

La m√©thode contextLoads est **annot√©e @Test** (annotation qui provient de JUnit ; quand je vous disais que d‚Äôautres frameworks utilisent les annotations üòâ), et n‚Äôa pas de contenu.

> Pourquoi n'est elle pas contenu ?

Tout simplement parce que son unique objectif est de **v√©rifier que le contexte Spring se charge bien**.

Sans m√©thode de tests (c‚Äôest-√†-dire sans m√©thode avec @Test), notre classe de test ne peut √™tre ex√©cut√©e, m√™me si elle est annot√©e @SpringBootTest. Pour parer √† cela, Spring Boot g√©n√®re une m√©thode vide annot√©e @Test, et qui sera donc toujours success pour JUnit (car elle est vide).

Ainsi, lors de l‚Äôex√©cution de cette m√©thode, le contexte Spring sera charg√©, et si ce dernier rencontre une erreur, alors l‚Äôex√©cution de la classe de test retournera une erreur.

Tr√®s bien ! Maintenant, testons notre HelloWorld !

> D‚Äôaccord, mais on teste quoi ?

Le but de ce cours n‚Äôest pas de vous expliquer les m√©thodologies de test. Mais rappelez-vous toujours qu‚Äôau sein d‚Äôun projet, on va **tester les traitements m√©tiers** pour s‚Äôassurer qu‚Äôils correspondent bien aux attendus.

Dans notre cas, le traitement m√©tier est repr√©sent√© par la m√©thode getHelloWorld() de la classe BusinessService.

Donc, nous allons tester cette m√©thode.

Je vous laisse essayer, voici quelques indices :
1. Ajoutez une nouvelle m√©thode de test.
2. Injectez une instance de BusinessService dans la classe de test.
3. V√©rifiez que l‚Äôattribut ‚Äúvalue‚Äù de l‚Äôobjet HelloWorld contient bien le texte ‚ÄúHello World!‚Äù.

Ensuite, il ne vous reste plus qu‚Äô√† faire un clic droit sur la classe, ‚ÄúRun As‚Äù, ‚ÄúJUnit Test‚Äù.

```java
package com.test.helloworld;

import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import com.test.helloworld.service.BusinessService;

@SpringBootTest
class HelloworldApplicationTests {

	@Autowired
	private BusinessService bs; 

	@Test
	void contextLoads() {
	}
	
	@Test
	public void testGetHelloWorld() {
		String expected = "Hello World!";
		
		String result = bs.getHelloWorld().getValue();
		
		assertEquals(expected, result);
	}

}
```

Analysons :
- Lignes 14/15 : j‚Äôinjecte une instance de BusinessService dans un attribut nomm√© bs. √Ä noter que sans l‚Äôannotation @SpringBootTest, cela √©chouera car sans contexte Spring, impossible de faire de l‚Äôinjection de d√©pendances.
- Lignes 21/22 : j‚Äô√©cris ma m√©thode, sans oublier d‚Äôannoter @Test.
- Ligne 23 : je d√©finis le r√©sultat attendu pour la valeur ‚ÄúHello World!‚Äù.
- Ligne 25 : je r√©cup√®re, √† travers l‚Äôinstance du BusinessService, un objet HelloWorld, puis j‚Äôappelle la m√©thode getValue et affecte le r√©sultat dans une variable nomm√©e result.
- Ligne 27 : gr√¢ce √† assertEquals, je compare les 2 variables. Si elles sont √©gales, le test r√©ussit, sinon il √©choue.

Allez ! Passons au d√©ploiement !

#### D√©couvrez les m√©thodes de d√©ploiement
Notre objectif est d√©sormais de d√©ployer et ainsi d‚Äôex√©cuter notre application.

> Le d√©ploiement correspond aux √©tapes qui permettent de passer de l‚Äôenvironnement de d√©veloppement √† l‚Äôenvironnement d‚Äôex√©cution.

L‚Äôenvironnement de d√©veloppement correspond g√©n√©ralement √† notre IDE. Dans le cas de ce cours, on utilise STS.

L'environnement d'ex√©cution peut varier. Il peut s'agit d'un environnement de tests ou d'un environnement de production. Notons que l‚Äôenvironnement de d√©veloppement peut √©galement √™tre un environnement d‚Äôex√©cution.

> Quel pr√©requis doit avoir un environnement d‚Äôex√©cution ?
Je suis s√ªr que vous connaissez la r√©ponse : tout simplement une JRE, qui permet ainsi l‚Äôex√©cution d‚Äôun programme Java.

> M√™me si c‚Äôest une application Spring, la simple JRE suffit ?
Tout √† fait, et c‚Äôest une tr√®s bonne nouvelle ! Rappelons que parmi les avantages de Spring Boot, il y a sa facilit√© de d√©ploiement car le JAR qui r√©sulte de la compilation embarque tout.

Par exemple, m√™me le serveur Tomcat qui permet d‚Äôex√©cuter une application web est embarqu√©. Nul besoin d‚Äôinstaller un serveur Tomcat, il est d√©j√† l√† !

R√©capitulons les m√©thodes employ√©es :
- √Ä travers l‚Äô**IDE** avec ‚ÄúRun As‚Äù, ‚ÄúSpring Boot App‚Äù.
- Avec **le goal Maven** `spring-boot:run`.
- **En ex√©cutant le JAR** gr√¢ce √† la commande `java -jar`.

Nous sommes bien d‚Äôaccord, le r√©sultat est le m√™me ! Gardons √† l‚Äôesprit que dans un contexte professionnel, on livrera g√©n√©ralement un JAR, et c‚Äôest ce dernier qui sera ex√©cut√©.

Les m√©thodes de d√©ploiement et d‚Äôex√©cution via l‚ÄôIDE et Maven sont surtout utiles pour les d√©veloppeurs.

#### En r√©sum√©
- Spring Boot fournit une **annotation @SpringBootTest qui permet de charger le contexte Spring** lors de l‚Äôex√©cution des tests.
- D√©ployer une application Spring Boot est tr√®s facile, car l‚Äôartefact qui en r√©sulte est un **simple JAR** o√π tout est embarqu√©.
- Il existe plusieurs m√©thodes pour ex√©cuter notre application Spring Boot :
    - Via l‚ÄôIDE directement.
    - Gr√¢ce √† Maven et au goal spring-boot:run.
    - En ex√©cutant la commande java -jar.

## Partie 3 - Cr√©ez une API avec Spring Boot
### Cr√©ez l'API avec les bons starters
Bienvenue dans la troisi√®me partie du cours sur Spring Boot !

> Que vas-tu nous apprendre, vu que l‚Äôon conna√Æt d√©sormais chaque √©tape pour programmer une application avec Spring Boot ?

Tututu, ne vous emballez pas, il y a tout √† apprendre encore ! C‚Äôest vrai, je vous ai appris √† vous servir du marteau pour planter un clou, mais avez-vous pour autant r√©alis√© un ouvrage digne de ce nom ? Je ne crois pas. 

C‚Äôest justement l‚Äôobjectif de la partie 3 et de la partie 4 de ce cours : r√©aliser des applications avec Spring Boot, qui vont bien au-del√† d‚Äôun simple Hello World ; c‚Äôest-√†-dire **construire un projet digne de ce nom**.

Je vous propose un deal pour chaque √©tape, je vous donne quelques indices, vous essayez puis on corrige.

Autant dire que vous n‚Äôallez pas vous ennuyer ! 

Pr√™t ?! Que la force soit avec vous ! 

#### Plongez-vous dans votre nouvelle mission
[Logo HR Association](https://user.oc-static.com/upload/2020/11/11/1605073055986_18.png)

HR Association est une entreprise qui souhaite offrir un service de gestion d‚Äôemploy√©s aux petites entreprises.

L‚Äôid√©e est d‚Äôoffrir une suite d‚Äôoutils num√©riques (logiciel, application web, voire application mobile) pr√™te √† l‚Äôemploi.

Voici l‚Äôarchitecture imagin√©e :

[Architecture des composants logiciels de HR Association](https://user.oc-static.com/upload/2020/11/11/16050731499577_image9.png)

Pour lancer ce projet, HR Association souhaite avant tout mettre √† disposition une API qui permettra √† toutes les autres applications d‚Äôacc√©der aux m√™mes donn√©es.

Vous allez r√©aliser une **API**. Rappelons-le, une API est un programme qui a pour vocation de **communiquer avec d‚Äôautres programmes**. L‚Äôid√©e √©tant de g√©rer des **employ√©s**, l‚ÄôAPI devra donc offrir un **CRUD** (Create, Read, Update, Delete) pour les donn√©es des employ√©s.

Les donn√©es seront dans une **base de donn√©es H2** (pour ceux qui sont un peu initi√©s aux bases de donn√©es, n‚Äôh√©sitez pas √† faire du MySQL, PostgreSQL ou autre).

> H2 est une base de donn√©es relationnelle Java tr√®s l√©g√®re, qui par d√©faut fonctionne en ‚Äúin memory‚Äù. Cela signifie qu‚Äôau d√©marrage du programme, la structure de la base est construite ; et lorsque le programme s‚Äôarr√™te, le contenu de la base de donn√©es est supprim√©. On ne conserve donc pas les modifications apport√©es d‚Äôune ex√©cution √† l‚Äôautre du programme.

Notre API devra donc **exposer des endpoints** correspondant aux actions du CRUD, et **communiquer avec la base de donn√©es** pour r√©cup√©rer ou modifier les informations des employ√©s. √Ä noter que l‚ÄôAPI sera de type **REST**.

> Besoin de d√©couvrir les API REST ? Par ici avec le cours [Adoptez les API REST pour vos projets web](https://openclassrooms.com/fr/courses/6573181-adoptez-les-api-rest-pour-vos-projets-web).

#### √Ä vous de jouer
Vous souvenez-vous de la premi√®re √©tape ? **Cr√©er la structure minimale du projet en d√©finissant les bons starters** !

Prenez en compte les besoins techniques de l‚Äôapplication, cherchez les starters dans la liste existante, et **regardez avec soin les descriptions** pour identifier ceux qui vous sont n√©cessaires ! On se retrouve dans quelques minutes pour la correction.

#### Correction : identifiez les bons starters pour cr√©er l'API
Quelques explications :
- Pour les ‚ÄúProject Metadata‚Äù, je suis rest√© simple :
    - group: com.openclassrooms (un standard) ;
    - artifact: api (on ‚Äúappelle un chat un chat‚Äù, n‚Äôest-ce pas ?).
- Pour les d√©pendances :
    - **Spring Web** : comme la description l‚Äôindique, permet de faire du RESTful, ce qui correspond √† notre API pour exposer des endpoints.
    - **Lombok** : vous ne pouviez pas le deviner, c‚Äôest une librarie pour optimiser certaines classes, je vous en parle un peu plus loin dans le chapitre.
    - **H2 Database** : comme on dit, ‚ÄúC'est comme le Port-Salut, c'est √©crit dessus‚Äù ; on veut faire du H2, alors on prend cette d√©pendance.
    - **Spring Data JPA** : permet de g√©rer la persistance des donn√©es avec la base de donn√©es ; peut-√™tre le plus difficile √† identifier pour vous si vous n‚Äôavez jamais fait de persistance de donn√©es avec Spring.

#### En r√©sum√© 
- Pour impl√©menter une API qui communique avec une base de donn√©es, 3 √©l√©ments sont essentiels :
    - Le starter web qui permettra d‚Äôexposer les endpoints.
    - Un starter pour g√©rer la persistance des donn√©es (comme Spring Data JPA).
    - La d√©pendance pour le driver de la base de donn√©es concern√©e (par ex. H2 Database ou MySQL Driver).

### Configurez et structurez votre API avec des packages
Notre structure minimale √©tant pr√™te, il nous faut d√©sormais :
- Structurer avec des packages, comme nous l‚Äôavons vu dans la partie 2.
- Configurer notre application. Vous allez pouvoir vous plonger dans la configuration de la base de donn√©es H2.

#### √Ä vous de jouer !
Je vous propose de passer √† l‚Äôaction : √† vous de structurer et de configurer l‚Äôapplication.

> Comment faire pour configurer l‚Äôacc√®s √† la base de donn√©es?

Pour configurer la **base de donn√©es H2**, il existe plusieurs m√©thodes possibles, que vous pourrez d√©couvrir gr√¢ce √† une simple recherche sur le Web.

Cependant, je vous encourage √† laisser le **comportement par d√©faut** qui implique du coup z√©ro configuration (partisans du moindre effort, bonjour ! ), et √† ajouter uniquement la **propri√©t√© pour activer la console** de visualisation de la base de donn√©es (je vous laisse chercher sur le Web ).

> Comment faire pour ins√©rer des donn√©es dans la base de donn√©es ?

Au-del√† de la configuration de H2, il s‚Äôagit aussi de fournir la structure de la base de donn√©es et des donn√©es. Pour vous aider, voici un fichier nomm√© [data.sql](https://github.com/OpenClassrooms-Student-Center/HR-Association/blob/master/api/src/main/resources/data.sql) qui contient la structure qui sera utilis√©e, ainsi que quelques donn√©es. 

Il s‚Äôagit d‚Äôune **unique table nomm√©e Employees, avec 5 colonnes**. Ce fichier est √† placer dans le r√©pertoire **src/main/resources**. 

Et rappelez-vous la puissance de Spring Boot : il sera pris en compte automatiquement sans que vous ayez quoi que ce soit √† faire ! De ce fait, **le script SQL sera ex√©cut√© au d√©marrage de l‚Äôapplication**, et votre base de donn√©es contiendra la table et les donn√©es.

Vous connaissez d√©sormais la musique, on se retrouve juste en dessous pour une correction !

#### Correction
##### Cr√©ez des packages
Certainement le plus facile de cet exercice, voici tout simplement le r√©sultat avec une capture d‚Äô√©cran :
<!-- ins√©rer image -->

##### D√©finissez les propri√©t√©s
Maintenant, parlons des propri√©t√©s et donc du fichier applications.properties : avez-vous repris les propri√©t√©s vues dans la partie 2 ? Avez-vous trouv√© la propri√©t√© pour activer la console H2 ?

Et voici mon r√©sultat :
```java
#Global configuration
spring.application.name=api

#Tomcat configuration
server.port=9000

#Log level configuration
logging.level.root=ERROR
logging.level.com.test=INFO
logging.level.org.springframework.boot.autoconfigure.h2=INFO
logging.level.org.springframework.boot.web.embedded.tomcat=INFO

#H2 Configuration
spring.h2.console.enabled=true
```

- spring.application.name=api : pour d√©finir un nom √† l‚Äôapplication ;
- server.port=9000 : pour ne pas √™tre sur le port par d√©faut 8080 ;
- logging.level :
    - root=ERROR : par d√©faut, seules les traces en ERROR s‚Äôaffichent. L‚Äôid√©e est simple : r√©duire les affichages dans la console de toutes les "3rd party",
    - com.openclassrooms=INFO : pour ce qui est de notre code, on est en INFO pour avoir du d√©tail,
    - org.springframework.boot.autoconfigure.h2=INFO : permet de voir dans la console l‚ÄôURL jdbc de la base H2,
    - org.springframework.boot.web.embedded.tomcat : permet de voir dans la console le port utilis√© par Tomcat au d√©marrage ;
- spring.h2.console.enabled=true : correspond √† la propri√©t√© pour activit√© de la console H2. 

Concernant la console H2, une fois l‚Äôapplication d√©marr√©e, vous pouvez aller sur l‚ÄôURL ‚Äúhttp://localhost:9000/h2-console‚Äù. Une fen√™tre de login s‚Äôouvre, et il est n√©cessaire d‚Äôindiquer l‚Äô**URL Jdbc** (qui change √† chaque d√©marrage de l‚Äôapplication).

Dans votre console, vous aurez une ligne qui doit ressembler √† la suivante :

`H2 console available at '/h2-console'. Database available at 'jdbc:h2:mem:9c5afa97-0c51-4c33-8578-c2872e4d2a25'` 

R√©cup√©rez l‚ÄôURL JDBC (en l'occurrence jdbc:h2:mem:9c5afa97-0c51-4c33-8578-c2872e4d2a25'), saisissez dans le formulaire comme ci-dessous, puis ‚ÄúConnect‚Äù. Le username par d√©faut est bien ‚Äúsa‚Äù, et le password par d√©faut est vide.

Une fois connect√©, vous pouvez consulter le contenu de votre table.

Nous voil√† pr√™ts pour la 3e √©tape : la structure de packages est cr√©√©e, la configuration est en place, et la base de donn√©es est fonctionnelle !

C‚Äôest l‚Äôheure d‚Äô√©crire le code !

> Envie de d√©couvrir la configuration pour une base de donn√©es MySQL ? Je vous invite √† lire la [documentation de Spring](https://spring.io/guides/gs/accessing-data-mysql/) (en anglais), notamment la section "Create the application.properties File".

#### En r√©sum√©
- Les besoins techniques du projet vont influer sur votre configuration.
- La structure des packages reste le standard : controller / service / repository / model.
- Gr√¢ce √† Spring Boot, la mise en ≈ìuvre de la base de donn√©es requiert 0 ligne de configuration, si ce n‚Äôest pour activer la console H2.

### Cr√©ez un contr√¥leur REST pour g√©rer vos donn√©es
Dans ce chapitre, oublions le mode exercice/correction, je ne veux pas vous faire chercher des heures et des heures si vous n‚Äôavez jamais eu l‚Äôoccasion de d√©velopper une API REST avec Spring. Je vous propose donc de vous montrer **pas √† pas comment arriver au r√©sultat final**, et je vous invite √† appliquer les √©tapes en m√™me temps que moi.

#### Mod√©lisez la table en entit√© Java
Premi√®re chose √† faire, afin de manipuler les donn√©es persist√©es dans la base de donn√©es, nous allons cr√©er une classe Java qui est une entit√©. Cela signifie que **la classe repr√©sente la table**. Chaque ligne de la table correspondra √† une instance de la classe. Cr√©ons la classe **Employee** dans le package com.openclassrooms.api.model.

Voici la classe en question :
```java
package com.test.api.model;

import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

import lombok.Data;

@Data
@Entity
@Table(name = "employees")
public class Employee {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name="first_name")
    private String firstName;

    @Column(name="last_name")
    private String lastName;

    private String mail;

    private String password;

}
```
Arr√™tons-nous sur ses sp√©cificit√©s :
- @Data est une annotation Lombok. Nul besoin d‚Äôajouter les getters et les setters. La librairie Lombok s‚Äôen charge pour nous. Tr√®s utile pour all√©ger le code.
- @Entity est une annotation qui indique que la classe correspond √† une table de la base de donn√©es.
- @Table(name=‚Äùemployees‚Äù) indique le nom de la table associ√©e.
- L‚Äôattribut id correspond √† la cl√© primaire de la table, et est donc annot√© @Id. D‚Äôautre part, comme l‚Äôid est auto-incr√©ment√©, j‚Äôai ajout√© l‚Äôannotation @GeneratedValue(strategy = GenerationType.IDENTITY).
- Enfin, firstName et lastName sont annot√©s avec @Column pour faire le lien avec le nom du champ de la table.

> Je n‚Äôai pas eu besoin de mettre cette annotation pour mail et password, car le nom du champ de la table est identique.

#### Impl√©mentez la communication entre l‚Äôapplication et la base de donn√©es
Une fois que l‚Äôentit√© est cr√©√©e, nous devons impl√©menter le code qui d√©clenche les actions pour communiquer avec la base de donn√©es. Bien √©videmment, ce code se servira de notre classe entit√©.

Le principe est simple, notre code fait une requ√™te √† la base de donn√©es, et le r√©sultat nous est retourn√© sous forme d‚Äôinstances de l‚Äôobjet Employee.

> Quel est ce code √† impl√©menter ?

**Une interface !**

> Mais une interface ne contient pas de code, comment peut-elle ex√©cuter des requ√™tes ?

C‚Äôest l√† toute la puissance du **composant Spring Data JPA** ! Il nous permet d‚Äôex√©cuter des requ√™tes SQL, sans avoir besoin de les √©crire.

Dans le package com.test.api.repository, cr√©ez une **interface** nomm√©e **EmployeeRepository**. Le code sera le suivant :
```java
package com.test.api.repository;

import org.springframework.data.repository.CrudRepository;
import org.springframework.stereotype.Repository;

import com.test.api.model.Employee;

@Repository
public interface EmployeeRepository extends CrudRepository<Employee, Long> {

}
```

Comme √† notre habitude, expliquons : @Repository est une annotation Spring pour indiquer que la classe est un bean, et que son r√¥le est de communiquer avec une source de donn√©es (en l'occurrence la base de donn√©es).
> En r√©alit√©, **@Repository** est une sp√©cialisation de **@Component**. Tout comme @Component, elle permet de d√©clarer aupr√®s de Spring qu‚Äôune classe est un bean √† exploiter. Par son nom, on fournit au d√©veloppeur une indication s√©mantique sur le r√¥le de la classe. Vous pourriez cependant utiliser l‚Äôannotation @Component, et cela fonctionnerait tr√®s bien, mais il est recommand√© d‚Äôutiliser les annotations qui offrent cette valeur s√©mantique suppl√©mentaire.

CrudRepository est une interface fournie par Spring. Elle fournit des m√©thodes pour manipuler votre entit√©. Elle utilise la g√©n√©ricit√© pour que son code soit applicable √† n‚Äôimporte quelle entit√©, d‚Äôo√π la syntaxe ‚ÄúCrudRepository**<Employee, Long>**‚Äù (je ne vous fais pas un cours sur la g√©n√©ricit√©, cela fait partie de vos acquis de d√©veloppeur Java )

> La classe entit√© fournie doit √™tre annot√©e @Entity, sinon Spring retournera une erreur.

Ainsi, vous pouvez utiliser les m√©thodes d√©finies par l‚Äôinterface CrudRepository. Pour en avoir la liste compl√®te, rendez-vous sur la [documentation](https://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/repository/CrudRepository.html). Je vous en dis plus dans la partie qui suit !

Et‚Ä¶ c‚Äôest tout ! G√©nial, non ? Une dizaine de lignes de code uniquement pour cette √©tape.

#### Cr√©ez un service m√©tier
Si nous analysons la structure cr√©√©e, nous avons tir√© profit des couches model et repository, mais rien n‚Äôa √©t√© fait dans les autres couches. Il reste donc ‚Äúservice‚Äù et ‚Äúcontroller‚Äù √† impl√©menter.

La couche ‚Äúservice‚Äù est d√©di√©e au ‚Äú**m√©tier**‚Äù. C‚Äôest-√†-dire appliquer des traitements dict√©s par les r√®gles fonctionnelles de l‚Äôapplication. Imaginez par exemple que votre application doive sauvegarder tous les noms des employ√©s en majuscules, mais que le nom nous arrive en minuscules.

√Ä quel endroit de notre code allons-nous effectuer l‚Äôop√©ration de mise en majuscules ? Vous l‚Äôavez compris, dans la couche ‚Äúm√©tier‚Äù.

Allez, j‚Äôen profite pour vous faire un r√©capitulatif de l‚Äôobjectif de chaque couche :

| **Couche** | **Objectif**                                  |
| ---------- | --------------------------------------------- |
| controller | R√©ceptionner la requ√™te et fournir la r√©ponse |
| service    | Ex√©cuter les traitements m√©tiers              |
| repository | Communiquer avec la source de donn√©es         |
| model      | Contenir les objets m√©tiers                   |

Ainsi, lorsqu‚Äôune requ√™te est r√©ceptionn√©e, la couche controller d√©l√®gue les traitements m√©tiers √† ex√©cuter. La couche service pourra ensuite faire appel √† la couche repository.

> Et quels sont nos traitements m√©tiers ?

Eh bien pour l‚Äôinstant, on n'en a pas.  Cependant, la couche service est √©galement un pont entre le controller et le repository. De ce fait, nous allons cr√©er une classe EmployeeService dont voici le code :
```java
package com.test.api.service;

import java.util.Optional;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import com.test.api.model.Employee;
import com.test.api.repository.EmployeeRepository;

import lombok.Data;

@Data
@Service
public class EmployeeService {

    @Autowired
    private EmployeeRepository employeeRepository;

    public Optional<Employee> getEmployee(final Long id) {
        return employeeRepository.findById(id);
    }

    public Iterable<Employee> getEmployees() {
        return employeeRepository.findAll();
    }

    public void deleteEmployee(final Long id) {
        employeeRepository.deleteById(id);
    }

    public Employee saveEmployee(Employee employee) {
        Employee savedEmployee = employeeRepository.save(employee);
        return savedEmployee;
    }

}
```

Vous noterez avec int√©r√™t que chaque m√©thode a pour unique objectif d‚Äôappeler une m√©thode de l'employeeRepository.

Un petit zoom sur l‚Äôannotation **@Service** : tout comme l‚Äôannotation @Repository, c‚Äôest une **sp√©cialisation de @Component**. Son r√¥le est donc le m√™me, mais son nom a une valeur s√©mantique pour ceux qui lisent votre code. Pour le reste, ce code devrait √™tre √† votre port√©e.

Passons maintenant √† la couche controller !

#### Exposez les endpoints REST
Nous arrivons √† la derni√®re √©tape. Nous sommes en train de d√©velopper une API, c‚Äôest-√†-dire une application qui va communiquer avec d‚Äôautres applications. Pour rendre cela possible, il est obligatoire de fournir aux applications qui voudront communiquer avec nous un **moyen** de le faire. 

> Notre application est comme une maison. Si on n'y met aucune porte, impossible d‚Äôy acc√©der ! Les portes de notre application sont ce qu‚Äôon appelle des **endpoints**. Un endpoint est associ√© √† une URL. Lorsqu'on appelle cette URL, on re√ßoit une r√©ponse, et cet √©change se fait en **HTTP**.

De plus, on va suivre le mod√®le **REST** (par exemple pour le format des URL). 

> Comment cr√©er ces fameux endpoints ? Comment l'associer √† une URL ? Dois-je √©crire des r√©ponses HTTP ? Comment suivre le mod√®le REST ? 

Souvenez-vous que l‚Äôun des avantages de Spring et Spring Boot est de vous fournir les composants logiciels qui vous √©vitent de faire du code complexe ! Le starter ‚Äúspring-boot-starter-web‚Äù nous fournit justement tout le n√©cessaire pour cr√©er un endpoint. Laissez-moi vous donner la recette. Il faut :
- une classe Java annot√©e **@RestController** ;
- que les m√©thodes de la classe soient annot√©es. Chaque m√©thode annot√©e devient alors un endpoint gr√¢ce aux annotations **@GetMapping**, **@PostMapping**, **@PatchMapping**, **@PutMapping**, **@DeleteMapping**, **@RequestMapping**.

Et‚Ä¶ c‚Äôest tout ! Encore une fois, la simplicit√© est de rigueur. Regardons cela en code :

```java
package com.test.api.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import com.test.api.model.Employee;
import com.test.api.service.EmployeeService;

@RestController
public class EmployeeController {

    @Autowired
    private EmployeeService employeeService;

    /**
    * Read - Get all employees
    * @return - An Iterable object of Employee full filled
    */
    @GetMapping("/employees")
    public Iterable<Employee> getEmployees() {
        return employeeService.getEmployees();
    }

}
```

C‚Äôest l‚Äôheure des explications !

Premi√®rement, @RestController atteint 2 objectifs :
1. Comme @Component, elle permet d‚Äôindiquer √† Spring que cette classe est un bean.
2. Elle indique √† Spring d‚Äô**ins√©rer le retour de la m√©thode au format JSON dans le corps de la r√©ponse HTTP**. Gr√¢ce √† ce deuxi√®me point, les applications qui vont communiquer avec votre API acc√©deront au r√©sultat de leur requ√™te en p**arsant la r√©ponse HTTP**.

Deuxi√®mement, j‚Äôai inject√© une instance d'EmployeeService. Cela permettra d‚Äôappeler les m√©thodes pour communiquer avec la base de donn√©es.

Troisi√®mement, j‚Äôai cr√©√© une m√©thode getEmployees() annot√©e @GetMapping(‚Äú/employees‚Äù).

Cela signifie que **les requ√™tes HTTP de type GET √† l‚ÄôURL /employees** ex√©cuteront le code de cette m√©thode. Et ce code est tout simple : il s‚Äôagit d‚Äôappeler la m√©thode getEmployees() du service, ce dernier appellera la m√©thode findAll() du repository, et nous obtiendrons ainsi tous les employ√©s enregistr√©s en base de donn√©es.

> C'est tout ?

Eh oui, c‚Äôest tout.  Il est vrai que je vous ai fait impl√©menter le cas le plus simple. Mais notez comment Spring Boot fait tout dans l‚Äôombre pour vous, vous ne vous √™tes pas pr√©occup√© de la conversion de votre code Java en JSON, ni de comment r√©ceptionner une requ√™te HTTP, et encore moins de comment √©crire une r√©ponse HTTP !

> Et si on veut ajouter un nouvel employ√© ? Ou supprimer un employ√© ?

Bonne question, c‚Äôest l√† o√π les autres annotations vont vous aider :
| **Annotation**  | **Type HTTP** | **Objectif**                                                 |
| --------------- | ------------- | ------------------------------------------------------------ |
| @GetMapping     | GET           | Pour la **lecture** de donn√©es.                              |
| @PostMapping    | POST          | Pour **l‚Äôenvoi** de donn√©es. Cela sera utilis√© par exemple pour cr√©er un nouvel √©l√©ment. |
| @PatchMapping   | PATCH         | Pour **la mise √† jour partielle** de l‚Äô√©l√©ment envoy√©.       |
| @PutMapping     | PUT           | Pour **le remplacement complet** de l‚Äô√©l√©ment envoy√©.        |
| @DeleteMapping  | DELETE        | Pour la **suppression** de l‚Äô√©l√©ment envoy√©.                 |
| @RequestMapping |               | Int√®gre tous les types HTTP. Le type souhait√© est indiqu√© comme attribut de l‚Äôannotation. Exemple :<br />@RequestMapping(method = RequestMethod.GET) |

Nous avons ici tout le n√©cessaire pour impl√©menter la cr√©ation d‚Äôun nouvel employ√© ou sa suppression, par exemple. Je ne vais pas tout vous montrer dans le d√©tail, car ce cours n‚Äôen finirait plus, sinon. 

Je vous ai tout de m√™me mis √† disposition ce repository avec toutes les actions impl√©ment√©es : [par ici](https://github.com/OpenClassrooms-Student-Center/HR-Association/tree/master/api). Allons maintenant v√©rifier si notre impl√©mentation est valide !

#### En r√©sum√©
- Notre entit√© du model est mod√©lis√©e, et @Entity est l‚Äôannotation obligatoire !
- La communication aux donn√©es s‚Äôeffectue via une classe annot√©e @Repository.
- La classe annot√©e @Service se charge des traitements m√©tiers.
- Nos controllers @RestController nous permettent de d√©finir des URL et le code √† ex√©cuter quand ces derni√®res sont requ√™t√©es.

### Testez votre API avec Spring Boot
Ce chapitre apportera une conclusion √† cette partie de cours. Notre objectif est de tester les controllers ; or, ces derniers seront appel√©s √† travers des URL par les programmes qui communiqueront avec.

La question est donc : comment simuler un appel de ce genre ?

C‚Äôest l√† o√π Spring Boot entre une nouvelle fois en jeu : il nous permet d‚Äôex√©cuter des requ√™tes sur notre controller. La cl√© de tout cela est l‚Äôannotation **@WebMvcTest**. Je vous propose de passer √† l‚Äôaction !
#### R√©digez des tests unitaires avec @WebMvcTest
Je ne vais pas vous abandonner √† votre sort pour cette grande premi√®re avec les tests et Spring Boot. Laissez-moi vous guider.

Commencez par observer le code suivant :
```java
package com.test.api;


import static org.hamcrest.CoreMatchers.is;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.test.web.servlet.MockMvc;

import com.test.api.controller.EmployeeController;
import com.test.api.service.EmployeeService;

@WebMvcTest(controllers = EmployeeController.class)
public class EmployeeControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private EmployeeService employeeService;

    @Test
    public void testGetEmployees() throws Exception {
        mockMvc.perform(get("/employees"))
            .andExpect(status().isOk());
    }

}
```

Quelques explications :
- **@WebMvcTest(controllers = EmployeeController.class)** d√©clenche le m√©canisme permettant de tester les controllers. On indique √©galement le ou les controllers concern√©s.
- L‚Äôattribut **mockMvc** est un autre √©l√©ment important. Il permet d‚Äôappeler la m√©thode ‚Äúperform‚Äù qui d√©clenche la requ√™te.
- L‚Äôattribut employeeService est annot√© **@MockBean**. Il est obligatoire, car la m√©thode du controller ex√©cut√©e par l‚Äôappel de ‚Äú/employees‚Äù utilise cette classe.

> Encore une fois, je vous redirige vers le cours sur [les tests](https://openclassrooms.com/fr/courses/6100311-testez-votre-code-java-pour-realiser-des-applications-de-qualite) si la notion de mock vous √©chappe. Pour rappel, un mock est un objet qui se substitue √† un autre objet.
- La m√©thode perform prend en param√®tre l‚Äôinstruction **get(‚Äú/employees‚Äù)**. On ex√©cute donc une requ√™te GET sur l‚ÄôURL /employees.
- Ensuite, l‚Äôinstruction **.andExpect(status().isOk())** indique que nous attendons une r√©ponse HTTP 200. 

L‚Äôutilisation de @WebMvcTest permet d‚Äô√©crire des **tests unitaires** sur le controller. Autrement dit, on v√©rifie uniquement le code ex√©cut√© dans la m√©thode du controller en mockant les appels au service.

#### R√©digez des tests d‚Äôint√©gration avec @SpringBootTest
Pour √©crire des **tests d‚Äôint√©gration**, on peut utiliser l‚Äôannotation @SpringBootTest que je vous ai d√©j√† pr√©sent√©e.

> Rappelons que les tests unitaires ont pour vocation √† tester uniquement le contenu d‚Äôune m√©thode, alors que les tests d‚Äôint√©gration impliquent de tester plus largement une fonctionnalit√©.

```java
package com.test.api;

import static org.hamcrest.CoreMatchers.is;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.servlet.MockMvc;

@SpringBootTest
@AutoConfigureMockMvc
public class EmployeeControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void testGetEmployees() throws Exception {
        mockMvc.perform(get("/employees"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$[0].firstName", is("Laurent")));
    }

}
```

Le code est tr√®s similaire, mais les diff√©rences sont les suivantes :
- Les annotations **@SpringBootTest** et **@AutoConfigureMockMvc** permettent de charger le contexte Spring et de r√©aliser des requ√™tes sur le controller.
- L‚Äôattribut annot√© @MockBean a disparu, plus besoin d‚Äôun mock pour EmployeeService, car ce dernier a √©t√© inject√© gr√¢ce √† @SpringBootTest.
- En plus de v√©rifier si le statut vaut 200, on v√©rifie le contenu retourn√© gr√¢ce √† `jsonPath("$[0].firstName", is("Laurent"))`. 
    - $ pointe sur la racine de la structure JSON.
    - [0] indique qu‚Äôon veut v√©rifier le premier √©l√©ment de la liste.
    - firstName d√©signe l‚Äôattribut qu‚Äôon veut consulter.
- is(‚ÄúLaurent‚Äù) est ce que l‚Äôon attend comme r√©sultat.

Pour finir ce chapitre pour le moins riche, je vous demande de d√©ployer votre projet. Je vous laisse r√©aliser cette t√¢che qui n‚Äôa rien de diff√©rent par rapport √† ce que vous avez d√©j√† fait dans la partie 2 de ce cours. 

#### En r√©sum√© 
- Des tests unitaires sur nos controllers REST sont ex√©cutables gr√¢ce √† @WebMvcTest.
- Des tests d‚Äôint√©gration sont ex√©cutables gr√¢ce √† @SpringBootTest et @AutoConfigureMockMvc.
- La proc√©dure de d√©ploiement ne subit aucun impact, c‚Äôest toujours la m√™me !

## Cr√©ez une application web avec Spring Boot
### Cr√©ez l'application web avec les bons starters
Bienvenue dans la quatri√®me et derni√®re partie de cours. Nous allons ensemble relever un dernier d√©fi : **r√©aliser une application web avec Spring Boot** !

#### Plongez-vous dans votre nouvelle mission
Votre mission, si vous l‚Äôacceptez, est d‚Äôaider HR Association dans la cr√©ation de sa suite d‚Äôoutils de gestion des employ√©s √† destination des petites entreprises.

Voici l‚Äôarchitecture imagin√©e :
[Architecture des composants logiciels de HR Association](./readMeIMG/image1.png)

Lors de la partie 3 de ce cours, nous avons r√©alis√© l‚ÄôAPI qui sera exploit√©e par les diff√©rents clients.

Aujourd‚Äôhui, l‚Äôobjectif est de d√©velopper une application web qui permettra de :
- Visualiser les employ√©s.
- Ajouter un nouvel employ√©.
- Modifier un employ√©.
- Supprimer un employ√©.

Voici un visuel :
[Page d‚Äôaccueil du syst√®me de gestion des employ√©s](./readMeIMG/accueil.png)

Techniquement, nous allons √©videmment utiliser **Spring Boot**, et je vous apprendrai comment renvoyer une page HTML et comment communiquer avec une API. Ce sera passionnant !

Allons-y ! 

#### √Ä vous de jouer !
Je vous laisse r√©aliser la premi√®re √©tape, √† savoir **cr√©er la structure minimale** de ce projet. Utilisez **Spring Initializr** ou bien **STS**, le r√©sultat sera le m√™me !

L‚Äôimportant est que vous choisissiez bien vos **starters** en fonction de ce que vous souhaitez r√©aliser. Cela ne sera pas facile pour vous, mais en parcourant attentivement la liste des starters et en lisant leur description, vous devriez pouvoir vous approcher du bon r√©sultat.

Pour les ‚Äú**Project Metadata**‚Äù, je suis rest√© simple, vous avez toute latitude pour saisir les donn√©es de votre choix.

Pour les ‚Äú**Dependencies**‚Äù, c‚Äôest ici que √ßa se complique !

Je pense que **Spring Web** a √©t√© une √©vidence pour vous ! Je vous f√©licite d‚Äôavoir mis le doigt dessus. Sachez que cela ne nous permettra pas uniquement de fournir une page HTML √† afficher. Ce starter contient √©galement le code pour communiquer avec une API.

Lorsque vous avez parcouru les ‚Äú**Template Engines**‚Äù, vous avez certainement not√© les mentions du HTML, et cela vous a peut-√™tre donn√© envie de choisir un de ces starters. Si c‚Äôest le cas, vous avez eu raison !

En plus de Spring Web, utilisons **Thymeleaf** qui est l‚Äôun des **moteurs de template** (template engine) les plus couramment utilis√©s.

En deux mots, un moteur de template HTML va nous **aider √† formater la page HTML** que nous voulons renvoyer.

Mon dernier starter, Lombok, est une librairie qui permet d‚Äôoptimiser certaines classes. Par exemple, gr√¢ce √† Lombok, en ajoutant l‚Äôannotation @Data √† une classe, je n‚Äôai plus besoin d‚Äô√©crire les getters et setters, magique !

#### En r√©sum√©
- Pour impl√©menter une application web qui communique avec une API, 2 √©l√©ments sont essentiels :
    - Le starter **Spring Web** qui permettra de renvoyer des pages HTML et communiquer avec l‚ÄôAPI.
    - Un **moteur de template** comme Thymeleaf qui permet de formater le HTML.

### Configurez et structurez votre projet avec des packages
Notre structure minimale √©tant pr√™te, il nous faut d√©sormais :
- Structurer avec des packages.
- Configurer notre application.

#### √Ä vous de jouer !
Pour la structure de packages, je vous encourage √† reprendre ce que je vous ai montr√© dans la [partie 2](https://openclassrooms.com/fr/courses/6900101-creez-une-application-java-avec-spring-boot/7077993-structurez-et-configurez-votre-projet). Comme indiqu√©, c‚Äôest une organisation standard qui s‚Äôapplique tr√®s bien aux projets web.

Pour la configuration, vous pouvez √©galement reprendre ce qu‚Äôon avait vu ensemble pr√©c√©demment concernant le fichier application.properties. On reste sur une configuration standard.

Je vous laisse la main, essayez de votre c√¥t√©, on se retrouve dans quelques minutes pour d√©briefer ces √©tapes.

#### Correction
##### Cr√©ez les packages
Certainement le plus facile de cet exercice, voici tout simplement la capture d‚Äô√©cran du r√©sultat.

> Cette structure en couches est utilisable **quel que soit l‚Äôobjectif fonctionnel**. Nous avons pu l‚Äôutiliser pour le HelloWorld de la [**partie 2**](https://openclassrooms.com/fr/courses/6900101-creez-une-application-java-avec-spring-boot/7077993-structurez-et-configurez-votre-projet), l‚ÄôAPI de la [**partie 3**](https://openclassrooms.com/fr/courses/6900101-creez-une-application-java-avec-spring-boot/7078013-configurez-et-structurez-votre-api-avec-des-packages), et d√©sormais pour cette application web.

##### D√©finissez les propri√©t√©s
Regardons maintenant le r√©sultat de la configuration du fichier application.properties.

Et voici mon r√©sultat en image :
```java
#Global configuration
spring.application.name=webapp

 #Tomcat configuration
 server.port=9001
 
 #Log level configuration
 logging.level.root=ERROR
 logging.level.com.openclassrooms=INFO
 logging.level.org.springframework.boot.web.embedded.tomcat=INFO
```

- spring.application.name=webapp : pour d√©finir un nom √† l‚Äôapplication ;
- server.port=9001 : pour ne pas √™tre sur le port par d√©faut 8080, ni sur le port 9000 qui est utilis√© par l‚ÄôAPI (Cf. partie 3 chapitre 2) ;
- logging.level :
    - root=ERROR : par d√©faut, seules les traces en ERROR s‚Äôaffichent. L‚Äôid√©e est simple : r√©duire les affichages dans la console de toutes les "3rd party",
    - com.openclassrooms=INFO : pour ce qui est de notre code, on est en INFO pour avoir du d√©tail,
    - org.springframework.boot.web.embedded.tomcat : permet de voir dans la console le port utilis√© par Tomcat au d√©marrage.

#### Allez plus loin dans la gestion des propri√©t√©s
Je souhaite saisir l‚Äôopportunit√© de ce chapitre pour vous apprendre √† cr√©er de la configuration **custom**. Jusqu‚Äô√† pr√©sent, je vous ai montr√© comment configurer votre application en fonction de propri√©t√©s existantes.

> Mais comment faire si on souhaite cr√©er de nouvelles propri√©t√©s ?

Rassurez-vous, Spring Boot s‚Äôoccupe de tout ! (Comme d‚Äôhab )

Dans la partie 2 du cours, chapitre 2, j‚Äôai eu l‚Äôoccasion de vous apprendre que Spring Boot lit **nos sources de propri√©t√©s**, et rend disponible les propri√©t√©s via des beans.

Le fichier application.properties correspond √† l‚Äôune de ces sources de propri√©t√©s.

Jusqu‚Äô√† pr√©sent, nous avons saisi des valeurs pour des propri√©t√©s existantes. Propri√©t√©s utiles √† des classes de Spring qu‚Äôon ne manipule pas. Cependant, si je souhaite ajouter une nouvelle propri√©t√©, comment y acc√©der dans mon code ?

##### √âtape 1 : Cr√©ez la nouvelle propri√©t√©.

J‚Äôai commenc√© par ajouter ma nouvelle propri√©t√© dans mon fichier application.properties (pour rappel, ce fichier est ma source de propri√©t√©s).
```
com.test.webapp.apiUrl=http://localhost:9003
```

##### √âtape 2 : Cr√©ez le bean associ√©.

J‚Äôai ensuite cr√©√© une nouvelle classe nomm√©e CustomProperties. Je l‚Äôai annot√©e avec :

@Configuration : permet de d√©clarer la classe en tant que bean de configuration.

@ConfigurationProperties(prefix = ‚Äúcom.openclassrooms.webapp‚Äù) : demande √† Spring de charger les properties qui commencent par ‚Äúcom.openclassrooms.webapp‚Äù au sein des attributs de la classe.

@Data : g√©n√®re automatiquement getter/setter pour les attributs de classe.

J‚Äôai conclu cette classe en ajoutant l‚Äôattribut apiUrl.

```java
package com.test.webapp;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Configuration;

import lombok.*;

@Data
@Getter
@Setter
@Configuration
@ConfigurationProperties(prefix="com.test.webapp")
public class CustomProperties {

	private String apiUrl;
}
```

##### √âtape 3 : Utilisez les propri√©t√©s dans le code.

Pour la d√©monstration, j‚Äôai modifi√© la classe WebappApplication, afin qu‚Äôelle impl√©mente un CommandLineRunner. Ainsi, dans la m√©thode run, j‚Äôai voulu v√©rifier que j‚Äôacc√©dais bien √† la propri√©t√©, en affichant cette derni√®re dans la console.

Le point cl√© √† retenir est l‚Äôinjection du bean CustomProperties, comme vous pouvez le voir aux lignes 16/17 ci-dessous.

Il est ensuite facile d‚Äôacc√©der √† la propri√©t√©, comme le montre la ligne 25.

```java
package com.test.webapp;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class WebappApplication implements CommandLineRunner {
	
	@Autowired
	private CustomProperties props;

	public static void main(String[] args) {
		SpringApplication.run(WebappApplication.class, args);
	}

	@Override
	public void run(String... args) throws Exception {
		System.out.println(props.getApiUrl());
		
	}

}
```

> Cette √©tape 3 servant uniquement √† d√©montrer que les √©tapes pr√©c√©dentes sont valides, je vais revenir √† la version initiale de la classe WebappApplication pour la suite du cours.

> Il est √©galement courant de cr√©er un nouveau package nomm√© "configuration" pour mettre les classes associ√©es. N‚Äôh√©sitez pas √† le faire.

#### En r√©sum√©
- La structure des packages reste le standard : **controller/service/repository/model**.
- Le fichier **application.properties** est ma source de propri√©t√©s.
- Je peux cr√©er des propri√©t√©s et les manipuler dans mon code, notamment gr√¢ce √† l‚Äôannotation **@ConfigurationProperties**.

### √âcrivez votre code 
#### Mod√©lisez l‚Äôobjet Employee
L‚Äôobjectif du code de ce projet sera de :
1. Communiquer avec l‚ÄôAPI REST pour r√©cup√©rer ou modifier les donn√©es des employ√©s.
2. Appliquer des traitements m√©tiers sp√©cifiques √† l‚Äôapplication web.
3. Afficher les pages web permettant de lister les employ√©s, cr√©er un nouvel employ√©, modifier un employ√© existant et supprimer un employ√© existant.

Les bonnes pratiques de programmation nous am√®nent √† avoir une approche MVC pour ce type d‚Äôapplication : Mod√®le - Vue - Contr√¥leur.
[Mod√®le MVC](./readMeIMG/mvc.png)

En quelques mots, on d√©coupe notre code en 2 p√¥les : le code ‚ÄúMod√®le‚Äù permet de d√©crire les donn√©es, le code ‚ÄúVue‚Äù permet d‚Äôafficher les donn√©es ; le code ‚ÄúContr√¥leur‚Äù traite les requ√™tes en interrogeant le ‚ÄúMod√®le‚Äù et en demandant √† la ‚ÄúVue‚Äù de s‚Äôafficher. Si on reprend le sch√©ma, voici donc les √©tapes :
1. Le contr√¥leur re√ßoit une demande d'un utilisateur, envoy√©e depuis le navigateur.
2. Le contr√¥leur demande les donn√©es au mod√®le.
3. Le contr√¥leur transmet les donn√©es √† la vue.
4. La vue affiche le r√©sultat sur le navigateur.

> Pour en savoir plus, vous pouvez consulter le cours [√âcrivez du code maintenable](https://openclassrooms.com/fr/courses/6810956-ecrivez-du-code-java-maintenable).

Pour suivre ce principe de programmation, nous devons identifier la ou les donn√©es que nous manipulons. En l'occurrence, la donn√©e que nous manipulons est un employ√© ! 

D‚Äôailleurs, une observation du code de l‚ÄôAPI nous confirme cela : la classe `com.test.api.controller.EmployeeController` contient des m√©thodes dont le type retour est un objet `Employee` ou bien `Iterable<Employee>`.

#### √Ä vous de jouer 
√Ä vous de jouer, √©crivez une classe Java de type POJO qui mod√©lise un employ√©.

```java
package com.test.webapp.model;

import lombok.Data;

@Data
public class Employee {

    private Long id;

    private String firstName;

    private String lastName;

    private String mail;

    private String password;
}
```

Quelle simplicit√©, n‚Äôest-ce pas ?!

Je me suis inspir√© de la classe com.openclassrooms.api.model.Employee. J‚Äôai donc mes 5 attributs mis √† disposition par l‚ÄôAPI :
- id ;
- firstName ;
- lastName ;
- mail ;
- password.

L‚Äôannotation `@Data` permet de g√©n√©rer automatiquement les getters et setters pour chaque attribut.

> Ce n‚Äôest pas une r√®gle absolue d‚Äôavoir l‚Äôobjet similaire entre la webapp et l‚ÄôAPI. On pourrait avoir un objet partiel c√¥t√© webapp (sans password par exemple, pour √©viter que cette donn√©e soit c√¥t√© web).

Notre classe Employee √©tant pr√™te, on peut s‚Äôint√©resser √† la communication entre l‚Äôapplication web et l‚ÄôAPI.

#### Impl√©mentez la communication entre l‚Äôapplication web et l‚ÄôAPI REST
Pour ceux qui ont suivi la partie 3 de ce cours, vous avez certainement √† l‚Äôesprit que la couche ‚Äúrepository‚Äù a permis de communiquer avec la base de donn√©es. Dans cette situation, la base de donn√©es correspondait √† **notre source de donn√©es**.

Mais pour l‚Äôapplication web, quelle est la source de ces donn√©es ? Le contexte de cette application vous l‚Äôa fait comprendre, c‚Äôest bien √©videmment l‚Äô**API** !

R√©sultat, notre objectif va √™tre de faire communiquer l‚Äôapplication web avec l‚ÄôAPI REST.

> Comment r√©ussir ?

Le starter Spring Web nous fournit tout le code n√©cessaire pour cela (d√©cid√©ment, Spring Boot ne nous d√©√ßoit jamais ! ). Nous allons nous servir de la classe **RestTemplate**.

> Suite √† l‚Äôav√®nement de la programmation r√©active, l‚Äôutilisation de l‚Äôobjet RestTemplate va progressivement √™tre remplac√©e par l‚Äôutilisation des classes du module Spring Webflux. Ainsi, vous trouverez sur le Web des notices ‚ÄúDeprecated‚Äù pour RestTemplate. Pas de panique, RestTemplate reste une fa√ßon valide de communiquer avec une API en synchrone, et c‚Äôest tr√®s bien pour nous d√©butants. Laissons la programmation r√©active de c√¥t√© pour le moment.

Vous ne pouvez pas deviner l‚Äôutilisation de RestTemplate, et je n‚Äôai pas envie que vous passiez des heures √† chercher ; alors laissez-moi vous montrer directement comment nous en servir :
```java
package com.test.webapp.repository;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.ParameterizedTypeReference;
import org.springframework.http.HttpMethod;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestTemplate;

import com.test.webapp.CustomProperties;
import com.test.webapp.model.Employee;

import lombok.extern.slf4j.Slf4j;

@Slf4j
@Component
public class EmployeeProxy {

    @Autowired
    private CustomProperties props;

    /**
    * Get all employees
    * @return An iterable of all employees
    */

    public Iterable<Employee> getEmployees() {
        String baseApiUrl = props.getApiUrl();
        String getEmployeesUrl = baseApiUrl + "/employees";

        RestTemplate restTemplate = new RestTemplate();
        ResponseEntity<Iterable<Employee>> response = restTemplate.exchange(
                getEmployeesUrl,
                HttpMethod.GET,
                null,
                new ParameterizedTypeReference<Iterable<Employee>>() {}
                );

        log.debug("Get Employees call " + response.getStatusCode().toString());
        
        return response.getBody();
    }

}
```

Le concept est le suivant : RestTemplate permet d‚Äôex√©cuter une requ√™te HTTP. On a donc besoin de fournir l‚ÄôURL, le type de requ√™te (GET, POST, etc.), et pour finir le type d‚Äôobjet qui sera retourn√©.

Ce dernier point est tr√®s important, RestTemplate non seulement fait la requ√™te √† l‚ÄôAPI mais en plus **convertit le r√©sultat JSON en objet Java** et √ßa, c‚Äôest top pour nous !

Si on d√©taille le code, voici les explications :
- Ligne 28 : gr√¢ce √† notre objet CustomProperties, on r√©cup√®re l‚ÄôURL de l‚ÄôAPI.
- Ligne 29 : on compl√®te l‚ÄôURL de l‚ÄôAPI par le path de l'endpoint √† joindre.
- Ligne 31 : on instancie notre objet RestTemplate.
- Ligne 32 : on appelle la m√©thode exchange en transmettant :
    - l‚ÄôURL ;
    - la m√©thode HTTP (gr√¢ce √† l‚Äôenum HttpMethod) ;
    - Null en lieu et place d‚Äôun objet HttpEntity, ainsi on laisse un comportement par d√©faut ;
    - le type retour, ici je suis oblig√© d‚Äôutiliser un objet ParameterizedTypeReference car /employees renvoie un objet Iterable<Employee>. Mais si l‚Äôendpoint renvoie un objet simple, alors il suffira d‚Äôindiquer <Object>.class. 
- Ligne 41 : on r√©cup√®re notre objet Iterable<Employee> gr√¢ce √† la m√©thode getBody() de l‚Äôobjet Response.

Vous pouvez tester ce code et constater la bonne r√©cup√©ration des donn√©es (n‚Äôoubliez pas de d√©marrer l‚ÄôAPI avant) !

> Tr√®s bien, mais comment faire si on souhaite √©galement fournir une donn√©e ? Par exemple, si je veux cr√©er un employ√©, comment faire pour envoyer √† l'API les informations du nouvel employ√© ?

Le code sera tr√®s similaire :
```java
public Employee createEmployee(Employee e) {
    String baseApiUrl = props.getApiUrl();
    String createEmployeeUrl = baseApiUrl + "/employee";

    RestTemplate restTemplate = new RestTemplate();
    HttpEntity<Employee> request = new HttpEntity<Employee>(e);
    ResponseEntity<Employee> response = restTemplate.exchange(
        createEmployeeUrl,
        HttpMethod.POST,
        request,
        Employee.class);

    log.debug("Create Employee call " + response.getStatusCode().toString());

    return response.getBody();
}
```

On retrouve notre objet **RestTemplate** et on fournit toujours l‚ÄôURL, la m√©thode HTTP (cette fois POST) et le type retour (en l‚Äôoccurrence Employee.class).

La grande diff√©rence correspond au nouvel objet **HttpEntity** qui, comme vous le constatez, a √©t√© instanci√© avec **en param√®tre du constructeur l‚Äôobjet Employee** (nomm√© e). 

Je transmets ensuite cet objet HttpEntity comme 3e param√®tre de la m√©thode exchange (ce param√®tre que nous avions mis √† null pr√©c√©demment).

Le tour est jou√© !

> Sur le repository GitHub correspondant au r√©sultat de cette partie, vous trouverez le code pour les actions create, update et delete.

#### Cr√©ez un service m√©tier
Le couche service a un double objectif :
- Ex√©cuter les traitements m√©tiers.
- Faire le relais vers la couche repository.

Souvenez-vous de ce tableau, partag√© dans un pr√©c√©dent chapitre :
| **Couche** | **Objectif**                                  |
| ---------- | --------------------------------------------- |
| controller | R√©ceptionner la requ√™te et fournir la r√©ponse |
| service    | Ex√©cuter les traitements m√©tiers              |
| repository | Communiquer avec la source de donn√©es         |
| model      | Contenir les objets m√©tiers                   |

Nous avons r√©alis√© les couches model et repository, et la couche service est la suivante. Maintenant que nous avons contextualis√© notre t√¢che, mettons-nous au travail.

Nous allons cr√©er une classe nomm√©e **EmployeeService** dans le package com.openclassrooms.webapp.service.

Bien √©videmment, cette classe devra √™tre identifi√©e comme √©tant un **bean**. L‚Äôannotation utilis√©e sera **@Service**, qui est une sp√©cialisation de l‚Äôannotation @Component que vous connaissez d√©j√†.

En ce qui concerne le contenu de la classe, nous allons √©crire des m√©thodes qui correspondront aux services mis √† disposition. Vu que nous restons dans la dynamique du CRUD, voil√† un r√©sultat possible :
```java
package com.test.webapp.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.test.webapp.model.Employee;
import com.test.webapp.repository.EmployeeProxy;

import lombok.Data;

@Data
@Service
public class EmployeeService {

    @Autowired
    private EmployeeProxy employeeProxy;

    public Employee getEmployee(final int id) {
        return employeeProxy.getEmployee(id);
    }

    public Iterable<Employee> getEmployees() {
        return employeeProxy.getEmployees();
    }

    public void deleteEmployee(final int id) {
        employeeProxy.deleteEmployee(id);;
    }

     public Employee saveEmployee(Employee employee) {
        Employee savedEmployee;

        // R√®gle de gestion : Le nom de famille doit √™tre mis en majuscule.
        employee.setLastName(employee.getLastName().toUpperCase());

        if(employee.getId() == null) {
            // Si l'id est nul, alors c'est un nouvel employ√©.
            savedEmployee = employeeProxy.createEmployee(employee);
        } else {
            savedEmployee = employeeProxy.updateEmployee(employee);
        }
    
        return savedEmployee;
    }

}
```

Bien que cette classe ne soit pas complexe, analysons les points cl√©s :
- Ligne 12 : annotation @Service, point cl√© comme expliqu√© pr√©c√©demment.
- Lignes 15/16 : l‚Äôobjet EmployeeProxy est inject√©, ainsi cette classe pourra faire appel √† la source de donn√©es √† travers le proxy.
- Les m√©thodes getEmployees(), getEmployee(final int id), deleteEmployee(final int id) sont de simples relais.
- Lignes 30 √† 44 : je vous ai simul√© un traitement m√©tier pour vous montrer la pertinence de cette couche. En l'occurrence, on met en majuscules le nom de famille. Cette r√®gle de gestion est dict√©e par un besoin fonctionnel, et c‚Äôest l‚Äôendroit parfait pour modifier notre objet avant qu‚Äôil ne soit sauvegard√© en base de donn√©es.

Je ne m‚Äô√©tends pas plus sur cette partie du code, qui rev√™tira toute son importance en fonction de la complexit√© fonctionnelle des applications que vous impl√©menterez.

#### Renvoyez les pages HTML
Au d√©but de ce chapitre, je vous ai parl√© de l‚Äôapproche **MVC**. Pour suivre cette approche, nous avons besoin de nous pencher sur la s√©paration entre le c**ode ‚Äúcontr√¥leur‚Äù** (traiter les requ√™tes entrantes) et le **code ‚Äúvue‚Äù** (construction du r√©sultat visuel √† fournir √† l‚Äôutilisateur).

> Comment renvoyer des pages HTML avec Spring Boot ?

C‚Äôest la question √† laquelle nous allons maintenant r√©pondre !

Lors du choix des starters, nous avons bien √©videmment s√©lectionn√© **Spring Web**, mais √©galement le moteur de template **Thymeleaf**. 

Il nous faut apprendre √† :
- Utiliser Spring Web pour traiter une requ√™te qui nous parvient.
- Utiliser Spring Web pour renvoyer une r√©ponse HTML.
- Formater notre r√©ponse HTML avec Thymeleaf.

Vous vous en doutez, Spring Boot va encore entrer en action pour nous simplifier la t√¢che.

Quel est notre point de d√©part ?

Un utilisateur va utiliser son navigateur web pour visualiser une page web de notre application. Pour cela, l‚Äôutilisateur saisit une URL.

Notre application web doit donc d√©clencher un traitement diff√©rent en fonction de l‚ÄôURL saisie (par exemple, un appel √† l‚ÄôURL http://www.monsite.com/ doit afficher la page d‚Äôaccueil, tandis qu‚Äôun appel √† http://www.monsite.com/contact doit afficher la page de contact).

C‚Äôest ici que les classes de type ‚Äòcontroller‚Äô vont entrer en jeu. Pour chaque URL, nous allons pouvoir impl√©menter une m√©thode qui contiendra le code √† ex√©cuter.

Ces m√©thodes devront :
1. R√©cup√©rer les donn√©es en entr√©e (s‚Äôil y en a).
2. Faire appel aux traitements m√©tiers (en l'occurrence, communiquer avec la couche service).

Retourner une vue HTML.

Mais attention, pour qu‚Äôune m√©thode d‚Äôun ‚Äòcontroller‚Äô puisse retourner une page HTML, il faut que cette derni√®re existe.

> Mais o√π √©crire notre code HTML ? Pas dans des classes Java, tout de m√™me ?

Vous avez raison, pas dans une classe Java ! Nous allons √©crire le HTML dans des **fichiers .html** que l‚Äôon nomme √©galement les **templates**. Et Spring Boot avait tout pr√©vu, regardez de plus pr√®s votre structure de projet :

Il y a ici un r√©pertoire **Templates** qui a pour vocation √† contenir vos fichiers HTML. Voici les √©tapes √† suivre :
- Ajoutons un fichier **home.html** qui servira de page d‚Äôaccueil. Je reviendrai sur ce fichier un peu apr√®s. Notez que cela correspond √† √©crire le code ‚ÄòVue‚Äô de notre concept MVC.
- Cr√©ons une classe nomm√©e **EmployeeController** dans le package controller.
- Annotons la classe EmployeeController afin qu‚Äôelle soit d√©tect√©e comme un bean, en utilisant l‚Äôannotation **@Controller**. De nouveau c‚Äôest une sp√©cialisation de @Component.

Je vous ai indiqu√© pr√©c√©demment que lors de l‚Äôappel d‚Äôune URL, une des m√©thodes du controller est ex√©cut√©e. Mais comment savoir quelle m√©thode utiliser ?

De nouveau gr√¢ce √† une annotation. Voici un exemple :
```java
@Controller
public class EmployeeController {

    @GetMapping("/")
    public String home() {
        return "home";
    }

}
```

Le concept est le suivant :
1. L‚Äôannotation sp√©cifie le type de requ√™te HTTP et l‚ÄôURL correspondante.
2. Le texte ‚Äúhome‚Äù retourn√© correspond au nom du fichier HTML.

C‚Äôest l√† que la magie de Spring Boot op√®re ! √Ä l‚Äôappel de l‚ÄôURL racine (via le type GET, qui est utilis√© par d√©faut dans les navigateurs) de mon application web, la m√©thode home() sera **automatiquement ex√©cut√©e**, et Spring **renverra automatiquement une r√©ponse** HTTP contenant dans son corps (donc le body HTTP) le contenu du fichier home.html. Tadaa !

#### √Ä vous de jouer !
Petit exercice pour vous :
1. Ajoutez un fichier home.html dans le r√©pertoire Template. 
2. Mettez un petit bout de HTML dedans (qu‚Äôimporte). 
3. Cr√©ez la classe EmployeeController avec le code ci-dessus.
4. Ex√©cutez votre webapp.
5. Allez sur http://localhost:9001/
6. Constatez le r√©sultat.

Alors, pas mal, hein ?

C‚Äôest un bon d√©but, mais nous avons besoin d‚Äôaller plus loin ! Vous devez certainement vous poser les questions suivantes :

> Comment afficher dans le HTML une donn√©e provenant du Java (par exemple une donn√©e r√©cup√©r√©e gr√¢ce √† la couche service) ?
> 
> Comment le code Java peut-il r√©cup√©rer une donn√©e provenant de la page web source (par exemple, ce qu‚Äôun utilisateur a saisi dans un formulaire) ?

Je vais vous expliquer comment faire ! Dans les deux cas, Spring Web nous fournit des objets pour r√©ussir, et Thymeleaf nous facilite la t√¢che.

> Attention, ce cours n‚Äôa pas pour vocation √† vous apprendre le HTML, le CSS, Thymeleaf ou m√™me Spring Web dans le d√©tail. Je vais donc vous montrer un exemple simple, et je vous encourage √† creuser pour aller plus loin.

#### Fournissez des donn√©es √† la vue
**Premi√®rement** : *Comment fournir des donn√©es √† la vue ?*
Spring met √† disposition diff√©rentes classes pour cela. Regardez cet exemple :
```java
@GetMapping("/")
public String home(Model model) {
    Iterable<Employee> listEmployee = service.getEmployees();
    model.addAttribute("employees", listEmployee);
    
    return "home";
}
```

L‚Äôobjet **Model** (org.springframework.ui.Model) a √©t√© ajout√© en param√®tre de la m√©thode home(). Gr√¢ce √† cela, Spring se charge de nous fournir une instance de cet objet.

Puis, dans le corps de la m√©thode, j‚Äôutilise une m√©thode *addAttribute* qui permet d‚Äôajouter √† mon Model un objet. Le premier param√®tre sp√©cifie le **nom** (de mon choix) et le deuxi√®me **l‚Äôobjet** (ici, la liste des employ√©s en Iterable). 

Ajouter des attributs au Model me permet d‚Äôy acc√©der dans la vue HTML. Comment ? Gr√¢ce √† Thymeleaf.

Je souhaite mettre en lumi√®re 2 aspects de ce code HTML :
```html
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhml" xmlns:th="http://www.thymeleaf.org">
    
    <head>
        <meta charset="UTF-8">
        <title>Employee Web Application</title>
    </head>
    <body>
        <h2 class="h2">Liste des employ√©es</h2>
        <table>
            <thead>
                <tr>
                    <th>Pr√©nom</th>
                    <th>Nom</th>
                </tr>
            </thead>
            <tbody>
                <tr th:if="${employees.empty}">
                    <td colspan="3">Aucun employ√©e en base de donn√©es</td>
                </tr>
                <tr th:each="employee: ${employees}">
                    <td><span th:text="${employee.firstName}"> Pr√©nom </span></td>
                    <td><span th:text="${employee.lastName}"> Nom </span></td>
                </tr>
            </tbody>
        </table>
    </body>
</html>
```

Les instructions **th:if** et **th:each** qui permettent respectivement d‚Äôimpl√©menter une condition et une it√©ration, fonctionnalit√©s non pr√©sentes en HTML. Thymeleaf me fournit donc la capacit√© d‚Äô√©crire un **code HTML dynamique**.

La syntaxe **\${nom de l‚Äôattribut}** permet d‚Äôacc√©der √† un objet plac√© comme attribut dans le Model. Notons √©galement que Thymeleaf comprend la programmation objet, et que la syntaxe **\${$objet.attribut}** fonctionne. C‚Äôest d‚Äôailleurs ce que je fais pour acc√©der aux pr√©nom et nom de l‚Äôemploy√©.

Vous pouvez tester ce code ;-)

#### R√©cup√©rez une donn√©e provenant de la page web source
**Deuxi√®mement** : *Comment le code Java peut-il, √† l‚Äôinverse, r√©cup√©rer une donn√©e provenant de la page web source ?*

Voyons 2 situations : une donn√©e transmise par URL (donc en GET) et une donn√©e transmise par formulaire (donc en POST).

##### Situation n¬∞ 1 : la donn√©e est transmise par URL
Int√©ressons-nous d‚Äôabord au cas d‚Äôune donn√©e transmise par URL :
```java
@GetMapping("/deleteEmployee/{id}")
public ModelAndView deleteEmployee(@PathVariable("id") final int id) {
    service.deleteEmployee(id);
    return new ModelAndView("redirect:/");
}
```

La m√©thode **deleteEmployee** poss√®de un param√®tre nomm√© id de type int ; cependant le point cl√© est l‚Äôannotation **@PathVariable** qui signifie que ce param√®tre est pr√©sent dans l‚ÄôURL de requ√™te (par exemple http://localhost:9001/deleteEmployee/1). Je peux ensuite me servir de la variable id dans le code : `service.deleteEmployee(id)`;

C√¥t√© Thymeleaf, voici le code correspondant :
```html
<a th:href="@{/deleteEmployee/{id}(id=${employee.id})}">Supprimer</a>
```

On utilise l‚Äôattribut **th:hreaf** de Thymeleaf, et la syntaxe **@{**} permet de d√©finir une URL. Le chemin `/deleteEmployee/` est compl√©t√© par l‚Äôid √† fournir gr√¢ce √† la syntaxe : `{id}(id==${employee.id})`.

Passons maintenant au cas d‚Äôune donn√©e transmise par un formulaire.

##### Situation n¬∞ 2 : la donn√©e est transmise par un formulaire
```java
@PostMapping("/saveEmployee")
public ModelAndView saveEmployee(@ModelAttribute Employee employee) {
    service.saveEmployee(employee);
    return new ModelAndView("redirect:/");
}
```

La m√©thode **saveEmployee** est annot√©e **@PostMapping** et non @GetMapping. Effectivement, il s‚Äôagit ici de traiter la validation d‚Äôun formulaire, et g√©n√©ralement les formulaires ex√©cutent des requ√™tes POST.

L‚Äôautre point cl√© est le param√®tre de la m√©thode `@ModelAttribute Employee employee`. @ModelAttribute est l‚Äôannotation magique. Cette annotation permet √† Spring de r√©cup√©rer les donn√©es saisies dans les champs du formulaire et de construire un objet Employee avec.

C√¥t√© Thymeleaf :
```html
<form method="post" th:action="@{/saveEmployee}" th:object="${employee}">
    <input type="text" th:field="*{firstName}">
    <input type="text" th:field="*{lastName}">
    <input type="text" th:field="*{mail}">
    <input type="password" th:field="*{password}">
    <button type="submit" c>Cr√©er</button>
</form>
```

**th: object=${employee}** fait le lien avec le ModelAttribute.

**th:field** donne la correspondance avec les attributs de l‚Äôobjet associ√©. Vous pouvez noter la syntaxe particuli√®re : ‚Äú***{firstName}**‚Äù.

Je vais m‚Äôarr√™ter l√† pour les explications pour ce chapitre. Il a √©t√© tr√®s dense, et j‚Äôai d√ª vous transmettre de nombreuses notions. La majorit√© sont d‚Äôailleurs √† approfondir et c‚Äôest normal, ici l‚Äôobjectif √©tait de vous lancer sur les rails, et non pas de vous accompagner jusqu‚Äôau bout du chemin.

Le plus important est que vous avez pu constater comment Spring Boot **vous rend plus performant** pour r√©aliser une application web !

> Vous pouvez retrouver sur ce [repository GitHub](https://github.com/OpenClassrooms-Student-Center/HR-Association/tree/master/webapp) le code complet, vous retrouverez ce que je vous ai montr√© et quelques d√©tails suppl√©mentaires ! 

### En r√©sum√©
- Cr√©er une application web avec Spring Boot correspond √† suivre l‚Äô**architecture MVC** :
    - le **mod√®le** correspond aux classes Java qui repr√©sentent les **donn√©es** √† manipuler ;
    - la **vue** correspond aux fichiers **HTML** qui seront retourn√©s √† l‚Äôutilisateur ;
    - le **contr√¥leur** correspond aux classes **Java** annot√©es @Controleur qui font du mapping d‚ÄôURL (avec par exemple @GetMapping) ;
    - les couches service et repository sont utilis√©es par les contr√¥leurs pour obtenir les donn√©es √† fournir √† la vue.
- **RestTemplate** est l‚Äôobjet cl√© pour **communiquer avec une API**. Non seulement il ex√©cute des requ√™tes HTTP, mais en plus il transforme le r√©sultat JSON en objet Java.

### Testez et d√©ployez votre projet web
Amis de Spring Boot, bonjour ! (Si vous √™tes arriv√©s √† ce dernier chapitre, c‚Äôest forc√©ment que vous √™tes devenus amis. )

Pour conclure ce projet web, nous devons non seulement le **tester**, mais √©galement le **d√©ployer**.

Ce chapitre ne devrait pas √™tre trop complexe pour vous, surtout si vous avez suivi la partie 3 du cours.

#### R√©alisez un test d‚Äôint√©gration
D‚Äôailleurs √† tous ceux qui ont suivi la partie 3, je vous propose l‚Äôexercice suivant : **r√©aliser un test d‚Äôint√©gration pour l‚Äôappel de la page d‚Äôaccueil** (donc URL : ‚Äú/‚Äù) ! On ne v√©rifiera pas le contenu, mais uniquement le statut. 

Pour les autres, je vous donne la solution juste en dessous.

√Ä travers le screencast suivant, je vais vous montrer ma fa√ßon de faire, et je vais m√™me vous en apprendre un peu plus.  C‚Äôest parti !

C‚Äô√©tait vraiment int√©ressant de r√©ussir √† tester en Java l‚Äôappel de notre contr√¥leur !

Je vous remets le code ici :
```java
package com.test.webapp;

import static org.hamcrest.CoreMatchers.containsString;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.view;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.AutoConfigureMockMvc;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.test.web.servlet.MockMvc;

@SpringBootTest
@AutoConfigureMockMvc
public class EmployeeControllerTest {

    @Autowired
    public MockMvc mockMvc;

    @Test
    public void testGetEmployees() throws Exception {
        mockMvc.perform(get("/"))
            .andDo(print())
            .andExpect(status().isOk())
            .andExpect(view().name("home"))
            .andExpect(content().string(containsString("Laurent")));
    }

}
```

Les points importants sont les suivants :
- L‚Äôannotation **@SpringBootTest** permet au contexte Spring d‚Äô√™tre charg√© lors de l‚Äôex√©cution des tests.
- Pour ex√©cuter une requ√™te au contr√¥leur, on utilise un objet **MockMvc** ; l‚Äôattribut correspondant doit √™tre annot√© @Autowired pour l'injection de la d√©pendance. Et la classe doit obligatoirement √™tre annot√©e **@AutoConfigureMockMvc**, afin qu‚Äôun objet MockMvc soit disponible dans le contexte Spring (ainsi il pourra √™tre inject√© dans l‚Äôattribut).
- La m√©thode **perform** a en param√®tre l‚ÄôURL √† appeler. Puis il s‚Äôensuit une suite d‚Äôinstructions pour v√©rifier l‚Äôattendu :
    - status().isOk() : la r√©ponse a un code de statut 200 ;
    - view().name(‚Äúhome‚Äù) : le nom de vue retourn√© correspond au param√®tre ‚Äúhome‚Äù ;
    - content().string(containsString("Laurent")) : le corps de la r√©ponse contient √† un moment ou √† un autre le texte Laurent.
- Notons √©galement que andDo(print()) permet au retour de l‚Äôappel d‚Äô√™tre affich√© dans la console (on y verra donc tout le HTML g√©n√©r√©).

> √Ä vous d‚Äô√™tre pertinent dans ce qui est attendu dans le corps de la r√©ponse !

#### D√©ployez votre application web
La derni√®re √©tape correspond au d√©ploiement. Gr√¢ce √† Spring Boot, c‚Äôest vraiment une formalit√© ; d‚Äôailleurs, √† vous de jouer : d√©ployez votre application ! 

Le screencast suivant sera le dernier du cours, et je vais vous montrer comment d√©ployer l‚Äôapplication web en ayant au pr√©alable √©galement d√©ploy√© l‚ÄôAPI.

Pour l‚Äôoccasion, j‚Äôai mis un peu de design sur les pages HTML (merci Bootstrap ). Regardons tout √ßa ensemble :

#### En r√©sum√©
- L‚Äôapplication web peut √™tre test√©e gr√¢ce √† @SpringBootTest.
- L‚Äôobjet MockMvc permet d‚Äôex√©cuter des requ√™tes, comme le ferait un navigateur web.
- Le d√©ploiement est facilit√© avec Tomcat qui est embarqu√© dans le JAR g√©n√©r√©.

## Le mot de fin
L‚Äôunivers Spring est immense, et il y a encore beaucoup √† d√©couvrir ; mais j‚Äôesp√®re que cette base sera un fondement solide pour la suite de votre progression. Prenez le temps de pratiquer, et allez encore plus loin !

Voici quelques id√©es :

Augmentez votre capacit√© √† utiliser Spring Web pour r√©aliser des applications web performantes.

D√©couvrez Spring Security pour la s√©curisation de vos applications.

Plongez-vous dans l‚Äôarchitecture microservices gr√¢ce √† Spring Cloud.

J‚Äôen suis convaincu, vous serez des d√©veloppeurs encore plus performants et efficaces !