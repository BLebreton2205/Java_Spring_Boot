# Java_Spring_Boot
Ceci est l'application de la formation Spring Boot proposer par OpenClassroom : https://openclassrooms.com/fr/courses/6900101-creez-une-application-java-avec-spring-boot

## Partie 1 - Identifiez pourquoi et quand utiliser Spring Boot
### Explorez les solutions apport√©es par Spring

Quelle est notre probl√©matique de base ? Construire une application qui :
1. Permet de r√©pondre aux besoins fonctionnels actuels.
2. Permettra de r√©pondre aux futurs besoins.
3. Et cela de fa√ßon efficiente !

> Un d√©veloppement **efficient** est un d√©veloppement **efficace**, c‚Äôest-√†-dire qui atteint les objectifs du projet mais en plus **√† moindre co√ªt**, avec **moins de ressources** humaines et en **moins de temps** ! 

#### Impl√©mentez un code √©volutif gr√¢ce au pattern Dependency Injection
> Comment √™tre capable de r√©pondre aux besoins futurs si on ne les conna√Æt pas encore ?
Notre application doit √™tre **√©volutive**. Notre code doit avoir la capacit√© d‚Äô√©voluer en impactant le moins possible l‚Äôexistant. Et comment r√©ussir ? Il nous faut **r√©duire les d√©pendances** au sein de notre code

##### Identifiez pourquoi les d√©pendances peuvent √™tre probl√©matiques
> Quel est le probl√®me avec les d√©pendances ? Pourquoi faut-il les r√©duire ?

Illustrons √† l‚Äôaide de l‚Äôexemple d‚Äôun objet Command et d‚Äôun objet Product : mon objet Command n√©cessite un objet Product. Il y a donc une d√©pendance entre les deux.

C‚Äôest l‚Äôobjet Command qui cr√©e l‚Äôobjet Product. Donc si l‚Äôobjet Product est modifi√©, l‚Äôobjet Command doit s‚Äôadapter lui aussi ! Il existe une **d√©pendance forte** entre les 2 objets. Le code suivant illustre cela :
```java
package com.openclassrooms.sb.sample;

public class Command {

    private Product product;

    public Command() {
        this.product = new Product(‚Äúsomething‚Äù);
    }

}
```

Si l‚Äôimpl√©mentation de Product change, alors le constructeur de Command sera impact√©.

Et si on veut utiliser une autre impl√©mentation de la classe Product, √† chaque changement il faudra toucher √† la classe Command.

R√©sultat : bye bye l‚Äô√©volutivit√© ! √Ä l‚Äô√©chelle de centaines, voire de milliers de lignes de code, notre application sera extr√™mement difficile √† maintenir dans le temps ! üôà

##### D√©couvrez la solution : Dependency Injection
Heureusement pour nous, un design pattern existe face √† ce probl√®me : *Dependency Injection*.

> Les design patterns, ou patrons de conception, sont des solutions standard aux probl√©matiques r√©currentes de d√©veloppement.

Rappelons notre probl√©matique : l‚Äôobjet Command a une d√©pendance forte avec l‚Äôobjet Product, car il doit s‚Äôoccuper de sa cr√©ation.

Mais imaginons maintenant que le processus de cr√©ation de l‚Äôobjet Product et son affectation dans l‚Äôobjet Command soient **d√©l√©gu√©s √† une tierce partie**. Voil√† que, par magie (ou presque), l‚Äôobjet Command n‚Äôa plus √† s‚Äôoccuper de l‚Äôobjet Product, et ce dernier ne se pr√©occupe d‚Äôailleurs pas non plus de l‚Äôobjet Command. 

Ce que je viens d‚Äô√©noncer est le principe du **design pattern Dependency Injection** !

Regardons le code :

```java
package com.openclassrooms.sb.sample;

public class Command {

    private Product product;

    public Product getProduct() {
        return product;
    }

    public void setProduct(Product product) {
        this.product = product;
    }

    public Command() { }

}
```

La diff√©rence √† noter est que le *‚Äúnew Product()‚Äù* a disparu. La classe Command ne s‚Äôoccupe plus de l‚Äôinstanciation. C‚Äôest notre fameuse tierce partie qui fera le n√©cessaire, et ins√©rera l‚Äôobjet instanci√© dans l‚Äôobjet Command gr√¢ce √† la m√©thode setProduct(), et cela de fa√ßon transparente.

Finie la d√©pendance forte ! √Ä l‚Äô√©chelle de centaines, voire de milliers de lignes de code, nous obtenons un programme dont les objets peuvent √©voluer bien plus facilement !

##### Impl√©mentez le pattern Dependency Injection avec Spring Framework
> Comment mettre en place cette tierce partie magique ? Dois-je la d√©velopper ?

Non, l‚Äôhiver est pass√©, le printemps est l√† ! Spring Framework s‚Äôoccupe de tout gr√¢ce √† son **IoC container** ! Ce dernier est aussi appel√© le ***contexte Spring***. Il vous permettra de cr√©er des objets dynamiquement, et de les injecter dans d‚Äôautres objets. De plus, on pourra facilement modifier l‚Äôimpl√©mentation d‚Äôun objet, avec quasiment z√©ro impact sur les objets qui utilisent ce dernier.

> IoC est le sigle de *Inversion of Control*. Cette expression indique un principe de programmation qui correspond au fait de d√©l√©guer √† un framework le flux de construction et d‚Äôappels des objets.

Les m√©canismes de l‚Äô**IoC container** rendront **votre code √©volutif, performant et robuste** ! Vous ne serez pas simplement efficace, vous serez efficient ! Durant ce cours, vous aurez l‚Äôoccasion de d√©couvrir comment utiliser le contexte Spring pour b√¢tir de solides applications Java !

#### Soyez plus performant gr√¢ce √† Spring Framework
Parmi nos probl√©matiques en tant que d√©veloppeur, il y a celle d‚Äô√™tre **performant** dans le d√©veloppement de notre projet. Cette performance peut √™tre li√©e au **temps** qu‚Äôon passe √† d√©velopper, mais aussi √† la **qualit√©** du code produit. Et pour cela, Spring Framework nous offre un bel avantage : **la configuration**.

Une des particularit√©s du framework est d‚Äôencourager (voire de forcer) les d√©veloppeurs √† impl√©menter certaines parties du code via de la configuration et non du d√©veloppement.

Prenons un exemple. Pour vous connecter √† une base de donn√©es en Java, vous avez besoin de :
- charger un driver de base de donn√©es (le driver MySQL, par exemple) ;
- cr√©er diff√©rents objets (comme *java.sql.Connection*) ;
- manipuler tous ces objets dans le bon ordre ;
- g√©rer les exceptions, etc. 

Bref, rien que de l‚Äô√©crire, √ßa m‚Äôa fatigu√© !  C‚Äôest pas vraiment complexe, mais c‚Äôest fastidieux !

Mais Spring Framework va nous permettre de r√©soudre tout √ßa en **quelques lignes** ! Non pas en quelques lignes de code, mais de **configuration** ! Pour cela, il nous suffit d‚Äôutiliser les **bons composants Spring** (j‚Äôy reviendrai dans le prochain chapitre) et le bon fichier de configuration :

spring.datasource.url=jdbc:mysql://localhost/test

spring.datasource.username=dbuser

spring.datasource.password=dbpass

spring.datasource.driver-class-name=com.mysql.jdbc.Driver

Voil√†, c‚Äôest r√©gl√© : au sein de l‚ÄôIoC container, tous les objets ont √©t√© cr√©√©s, et on peut interagir avec notre base de donn√©es !

Qu‚Äôen dites-vous ? N‚Äôest-ce pas beaucoup plus performant ? ;-)

Et ce n‚Äôest qu‚Äôun exemple parmi tant d‚Äôautres !

#### D√©couvrez les autres avantages de Spring
Ne partez pas si vite ! Ce n‚Äôest pas fini, Spring Framework est √©galement un **outil tr√®s puissant** car il simplifie certaines actions, indispensables pour r√©pondre √† nos besoins actuels, que nous aurions beaucoup de mal √† r√©aliser par nous-m√™mes. Par exemple :
- Interagir avec une base de donn√©es.
- Traiter des requ√™tes HTTP et √©crire des r√©ponses HTTP.
- Ex√©cuter des traitements par lots (batch).
- G√©rer la s√©curit√© de l‚Äôapplication.
- Etc.

Il ne se limite donc pas √† nous fournir l‚ÄôIoC container, il r√©pond quasiment √† **tous nos besoins techniques**, ce qui augmente aussi notre performance !

> Est-ce vraiment possible qu‚Äôun framework soit si complet ? ü§©

**Oui !** Tout d‚Äôabord car aujourd‚Äôhui une grande part des projets sont des applications construites avec les **technologies web**. Et Spring est tr√®s fort dans ce domaine ! Ensuite, car il est suffisamment ouvert pour permettre d‚Äôinclure d‚Äôautres **librairies** qui seraient n√©cessaires afin de compenser ses manques.

#### En r√©sum√©
- En tant que d√©veloppeurs, nous sommes face √† de nombreuses probl√©matiques : l‚Äô√©volutivit√©, les performances, etc.
- Spring Framework nous offre des **solutions concr√®tes** √† ces probl√©matiques :
    - l‚Äô**IoC container** pour l‚Äôimpl√©mentation du pattern **Dependency Injection** ;
    - la capacit√© de **configurer** plut√¥t que de d√©velopper ;
    - **des composants** pour g√©rer une multitude d‚Äôaspects, comme par exemple interagir avec des bases de donn√©es, ou traiter des requ√™tes HTTP.

### D√©couvrez le framework Spring
Spring est un **framework**, c‚Äôest-√†-dire un **cadre de travail existant** que les d√©veloppeurs peuvent utiliser. Imaginez que vous vouliez r√©am√©nager votre cuisine, allez-vous construire de z√©ro le moindre tuyau, meuble ou accessoire ? ü§î Absolument pas ! Ce serait une perte de temps, et peut-√™tre m√™me de qualit√©. 

La solution ? Direction les magasins sp√©cialis√©s pour acheter le n√©cessaire. Mais attention ! Vous restez responsable de choisir les bons meubles, de les monter, de faire en sorte que tout s‚Äôassemble pour obtenir un r√©sultat final homog√®ne.

Spring Framework, c‚Äôest un peu comme un **grand magasin sp√©cialis√©** : il y a de nombreuses choses √† trouver, et apr√®s, √† nous de faire l‚Äôassemblage. Faisons un tour des rayons ensemble ! üßê

![composantsSpring](/readMeIMG/composantsSpring.png)

#### Spring Core
Ce composant est **la base de l‚Äô√©cosyst√®me** Spring. 

Il contient le **‚Äúcore container‚Äù** (ce qui permet l‚Äôinjection de d√©pendances vue pr√©c√©demment), mais il contient √©galement **Spring MVC** qui permet de faire du web et de Data Access qui fournit des √©l√©ments fondamentaux pour la communication avec les bases de donn√©es.

> Pour avoir tout le d√©tail, suivez la [documentation officielle](https://spring.io/projects/spring-framework) sur Spring Core.

#### Spring Data
Ce composant permet de **communiquer avec de nombreux types de bases de donn√©es**. Par exemple, il offre la capacit√© de communiquer avec une base de donn√©es en impl√©mentant uniquement des interfaces gr√¢ce √† des conventions de nommage : bluffant !

> Pour avoir tout le d√©tail, suivez la [documentation officielle](https://spring.io/projects/spring-data) sur Spring Data.

#### Spring Security
Pensez-vous que la s√©curit√© soit un √©l√©ment essentiel d‚Äôune application ? Moi, oui ! Et des millions de d√©veloppeurs partagent ce point de vue. C‚Äôest pour √ßa que ce composant est l‚Äôun des plus critiques de Spring Framework, bien qu‚Äôil soit aussi l‚Äôun des plus complexes.
Il permet de g√©rer **l‚Äôauthentification**, **l‚Äôautorisation**, mais aussi la **s√©curit√© des API**.

> Pour avoir tout le d√©tail, suivez la [documentation officielle](https://spring.io/projects/spring-security) sur Spring Security. 

#### Spring Cloud
Avez-vous entendu parler de **l‚Äôarchitecture microservice** ? Si ce n‚Äôest pas le cas, ne vous inqui√©tez pas, mais cela va venir tr√®s vite car c‚Äôest le mod√®le d'architecture le plus pris√© actuellement. Et pour r√©pondre aux contraintes de cette architecture logicielle, Spring Framework fournit Spring Cloud. 

> Pour avoir tout le d√©tail, suivez la [documentation officielle](https://spring.io/projects/spring-cloud) sur Spring Cloud.

#### Spring Boot
C‚Äôest un composant tr√®s particulier de Spring Framework, dans la mesure o√π il nous permet de mettre en ≈ìuvre tous les autres. Ce cours vous montrera comment tirer profit de la puissance de Spring Boot, et de ses avantages qui sont :
- l'**autoconfiguration** automatique de Spring ;
- des **starters de d√©pendances** ;
- des **endpoints Actuator** pour fournir des donn√©es sur l‚Äôapplication.

>Pour avoir tout le d√©tail, vous pouvez suivre la [documentation officielle](https://spring.io/projects/spring-boot) sur Spring Boot. 
>
>Et ce n‚Äôest pas tout ! Pour explorer tous les autres projets, vous pouvez vous rendre sur [cette page](https://spring.io/projects).

#### En r√©sum√©
- Spring propose de **nombreux composants** pour r√©pondre aux besoins des d√©veloppeurs !
- L‚Äôun des plus utiles est **Spring Boot**, car il permet de mettre en ≈ìuvre les autres composants de Spring avec facilit√©, notamment gr√¢ce **aux starters de d√©pendances** et √† **l‚Äôautoconfiguration**.

### Identifiez les avantages de Spring Boot

#### Simplifiez votre projet avec Spring Boot
Vous l‚Äôavez not√©, Spring est un √©cosyst√®me avec un grand E ! √Ä tel point que parfois ce framework peut m√™me sembler trop rigide, trop encombrant ou trop complexe, il faut le reconna√Ætre. De plus, il contient de nombreux composants, et ces derniers ne s‚Äôutilisent pas de fa√ßon exclusive : dans la tr√®s grande majorit√© des projets, vous devrez utiliser **plusieurs composants de Spring simultan√©ment**. Par voie de cons√©quence, l‚Äôint√©gration de plusieurs composants Spring pour un m√™me projet ajoute de la complexit√©. **Complexit√© qui sera croissante** plus le projet prendra de l‚Äôimportance !

Non non, ne fuyez pas !üòÖ Rassurez-vous, une solution existe ! Nous pouvons tirer profit de tous les avantages de Spring sans y perdre notre latin !

> Comment faire ? üò±

Je vous en ai d√©j√† bri√®vement parl√© au chapitre pr√©c√©dent, il s‚Äôagit d‚Äôutiliser **Spring Boot** ! Ce composant de Spring a √©t√© cr√©√© pour nous aider √† utiliser Spring Framework. C‚Äôest un composant **au service des autres composants**.

Illustrons l‚Äôid√©e. Vous vous souvenez peut-√™tre de la comparaison que j‚Äôai d√©j√† utilis√©e : Spring Framework est comme un grand magasin sp√©cialis√© de meubles, o√π un composant est tel un meuble que l‚Äôon peut acheter.

Eh bien Spring Boot, c‚Äôest comme des gammes de meubles qui nous sont propos√©es. Lorsqu‚Äôon ach√®te un meuble, il est certain que les autres meubles de la m√™me gamme iront ensemble (c‚Äôest pour √ßa que c‚Äôest une gamme !), et cela √©vite les surprises lors de l‚Äôassociation des meubles.

L√†, c‚Äôest pareil : Spring Boot nous met √† disposition les bons composants, nous permettant ainsi de les faire fonctionner ensemble.

Et cela contribuera √† la **simplification** de notre projet !

#### √Ä vous de jouer !
Jouons au jeu des 7 diff√©rences ! Je vous propose de comparer deux projets Java qui utilisent Spring Framework. L‚Äôun utilise le composant Spring Boot, l‚Äôautre non.

La consigne est simple : **Quelles diff√©rences pouvez-vous observer ?**

Projet **[sans](https://github.com/OpenClassrooms-Student-Center/creez-une-application-spring-boot/tree/master/webwithoutsb)** Spring Boot;

Projet **[avec](https://github.com/OpenClassrooms-Student-Center/creez-une-application-spring-boot/tree/master/webwithsb)** Spring Boot.

Alors, qu‚Äôavez-vous not√© ?

Je vous d√©cris les diff√©rences entre ces deux projets, en mettant en avant les avantages de Spring Boot ‚úÖ.
| **R√©pertoires**    | **Sans Spring Boot**                                         | **Avec Spring Boot**                                         |
| :----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| src/main/java      | 4 classes Java : <br />   1. HomeController.java<br />   2. User.java<br />   3. UserRepository.java<br />   4. **JpaConfig.java** : c‚Äôest moi qui ai cr√©√© cette classe‚Ä¶ üòÖ | 4 classes Java :<br />   1. HomeController.java<br />   2. User.java<br />   3. UserRepository.java<br />   4. **WebwithsbApplication.java** : c‚Äôest une classe cr√©√©e automatiquement par Spring Boot, plus de perte de temps ! ‚úÖ |
| src/main/resources | - **contextFront.xml** : configuration manuelle du scanning et du viewresolver<br /> - **META-INFO/persistence.xml** : contient la configuration de la BDD | - **Pas besoin de contextFront** : Spring Boot s‚Äôen occupe ! ‚úÖ<br /> - **application.properties** : contient la configuration de la BDD. Est plus simple √† aborder que XML. <br /> - ‚úÖ**template/home.html** : rendu HTML √† fournir. |
| src/main/webapp    | **2 fichiers** :<br /> - **template/home.jsp** : rendu HTML √† fournir<br /> - **web.xml** : fournit de la configuration pour la gestion des servlets | Ce dossier **n‚Äôexiste pas** ! Spring Boot n‚Äôa pas besoin de tout √ßa ! ‚úÖ |
| fichiers pom.xml   | **8** d√©pendances<br />+ **2** d√©pendances dans le dependencyManagement pour les versions | **5** d√©pendances **sans avoir d√©fini les versions**         |

üëâ Moins de fichiers, plus d‚Äôautomatisation‚Ä¶ Bref, c‚Äôest une victoire tr√®s nette de Spring Boot, qui nous simplifie la vie !

Et cerise sur le g√¢teau : pour le d√©ploiement, le projet avec Spring Boot se lance avec une simple commande, alors que le projet sans Spring Boot me demande d‚Äôinstaller un serveur web (comme Tomcat) pour le d√©ployer et le d√©marrer.

Vraiment, jusqu‚Äôau bout, Spring Boot nous simplifie les choses ! ü§©

#### Les avantages de Spring Boot
Reprenons notre souffle apr√®s cet exercice, et analysons les avantages de Spring Boot.

##### Avantage n¬∞ 1 : optimisation de la gestion des d√©pendances
Spring Boot nous fournit des **starters**, qui correspondent √† un ensemble de d√©pendances homog√©n√©is√©es (associations, versions). On peut les comparer √† des **kits de d√©pendances**.
[Les Starters](https://user.oc-static.com/upload/2020/11/10/1605004979024_image3.png)

Nul besoin de d√©finir les versions des d√©pendances explicitement dans le pom.xml : Maven les d√©duit gr√¢ce √† la version de Spring Boot utilis√©e.

Dans ce cours, nous allons apprendre √† choisir les bons starters en fonction du besoin.

##### Avantage n¬∞ 2 : l‚Äôautoconfiguration
C‚Äôest peut-√™tre l‚Äôavantage le plus important de Spring Boot ! L‚Äôexercice pr√©c√©dent l‚Äôa r√©v√©l√© : avec Spring Boot, il y a beaucoup moins de configuration (concernant la gestion des servlets, le chargement du contexte Spring, la connexion √† la base de donn√©es). Ce n‚Äôest pas un hasard. L‚Äôutilisation de Spring Boot, et l‚Äôannotation @SpringBootApplication plac√©e au niveau de la classe principale de notre projet (celle g√©n√©r√©e automatiquement), d√©clenchent automatiquement de nombreuses op√©rations en background qui nous sont n√©cessaires.

Le d√©veloppeur peut alors **se concentrer sur le code m√©tier** au lieu de passer un temps fou √† configurer le framework qu‚Äôil utilise.

Au fur et √† mesure du cours, je vous en dirai plus sur les op√©rations que Spring Boot r√©alise en background.

##### Avantage n¬∞ 3 : la gestion des propri√©t√©s
Spring Boot permet de **g√©rer les propri√©t√©s au sein d‚Äôun programme en toute simplicit√©**.

Dans l‚Äôexercice, vous avez pu voir le fichier **applications.properties**. Les informations qui √©taient saisies ont √©t√© prises en compte par certaines classes, sans que nous ayons besoin d‚Äôagir. Ce fichier est **l‚Äôun des √©l√©ments cl√©s** pour la gestion des propri√©t√©s de notre programme.

Mais cela ne se limite pas √† ce simple fichier ; par exemple, il est facilement possible de r√©cup√©rer m√™me des variables d‚Äôenvironnement syst√®me, et de les fournir √† nos classes.

Dans ce cours, nous d√©couvrirons comment tirer profit de la capacit√© de Spring Boot √† g√©rer les propri√©t√©s.

##### Avantage n¬∞ 4 : le monitoring et la gestion du programme
Je ne souhaite pas rentrer dans le d√©tail ici, mais sachez que **Spring Boot Actuator** correspond √† une fonctionnalit√© de Spring Boot qui permet de **monitorer et de manager notre programme** pendant qu‚Äôil est en cours d‚Äôex√©cution.

Par exemple, gr√¢ce aux **endpoints Actuator**, on peut modifier une propri√©t√© en live, et le programme en tiendra compte sans qu‚Äôon ait besoin de le red√©marrer. Tr√®s utile !

##### Avantage n¬∞ 5 : le d√©ploiement
Quel est l‚Äôartefact produit par un projet Spring Boot ? Un simple fichier JAR. 

Que faut-il pour ex√©cuter un JAR ? Vous le savez, une JRE, et c‚Äôest tout !
> Mais comment est-ce possible pour une application web qui a forc√©ment besoin d‚Äôun serveur de conteneur web ?

Un projet Spring Boot contient un tomcat embarqu√© au sein m√™me du JAR g√©n√©r√©. Le projet web peut donc √™tre d√©ploy√© au sein de ce tomcat embarqu√©.

Conclusion, ex√©cuter notre projet Spring Boot, quelles que soient ses fonctionnalit√©s, est tr√®s simple ! Et cela permet de coupler facilement nos projets Spring Boot avec d‚Äôautres outils comme Docker.

#### En r√©sum√©
- Spring Boot ≈ìuvre pour la **simplification** du d√©veloppement de nos projets avec Spring Framework.
- La gestion des d√©pendances est simplifi√©e gr√¢ce aux **starters** qui **regroupent plusieurs d√©pendances** et **homog√©n√©isent les versions**.
- L‚Äô**autoconfiguration** permet de **se concentrer sur le code m√©tier**, et simplifie √©norm√©ment la mise en ≈ìuvre des composants Spring qui sont utilis√©s.
- La gestion efficace des propri√©t√©s rend notre application **configurable**.
- Spring Boot **Actuator** permet de **monitorer** et **g√©rer** une application **pendant son ex√©cution**.
- Le d√©ploiement de l‚Äôapplication est facilit√© par la g√©n√©ration d‚Äôun JAR, et pour les projets web, un **tomcat est embarqu√©**.

## Partie 2 - D√©couvrez les √©tapes cl√©s de tout projet Spring Boot

### Cr√©ez votre projet
Dans cette partie de cours, nous allons ensemble d√©couvrir les √©tapes cl√©s pour tout projet Spring Boot. Cette partie est construite comme une sorte de mode d‚Äôemploi, auquel vous pouvez vous r√©f√©rer quelle que soit l‚Äôapplication que vous r√©alisez !

Cr√©ons ensemble le fameux **‚ÄúHello World‚Äù** avec Spring Boot !

Tout d‚Äôabord, voici le plan d‚Äôaction pour tout projet Spring Boot :
1. Cr√©er le projet, c‚Äôest-√†-dire g√©n√©rer la structure minimale.
2. Structurer et configurer le projet.
3. √âcrire le code.
4. Tester et d√©ployer.

Chaque √©tape du plan d‚Äôaction correspond √† un chapitre de cette partie du cours. Et les 2 parties de cours suivantes sont construites sur la base des m√™mes √©tapes.

C‚Äôest parti pour la premi√®re √©tape : **cr√©ons notre projet !** üòé

#### D√©couvrez les starters
> On commence par quoi ?

La premi√®re √©tape implique de g√©n√©rer la base de votre projet. Vous devez savoir qu‚Äôon ne commence pas sur une feuille blanche. Spring Boot nous fournit une base de travail que l‚Äôon peut nommer la **structure minimale**. On enrichira ensuite cette structure minimale en fonction des besoins de notre projet.

Pour obtenir cette structure minimale, il y a plusieurs solutions que l‚Äôon explorera dans la suite du chapitre. Mais avant de foncer t√™te baiss√©e, sachez que Spring Boot va vous demander un certain nombre d‚Äôinformations, comme :
- la version de Java ;
- Maven ou Gradle ;
- la version de Spring Boot ;
- des informations sur le projet (groupId, artifactId, nom du package) ;
- les d√©pendances.

Pour les premiers √©l√©ments, ce ne sera pas difficile ; √ßa pourrait par contre le devenir pour le choix des d√©pendances, car Spring Boot utilise quelque chose de nouveau : **les starters de d√©pendances**.

J‚Äôai d√©j√† eu l‚Äôoccasion dans la partie pr√©c√©dente de vous en parler, mais un rappel ne fera pas de mal.

Spring Framework se d√©coupe en de nombreux composants ; les utiliser implique de renseigner les bonnes d√©pendances pour notre projet. Ce n‚Äôest pas facile, car il faut savoir quelle d√©pendance est n√©cessaire √† quelle autre d√©pendance, s‚Äôil y a des incompatibilit√©s, et quelles sont les versions √† utiliser.

Pour r√©soudre cette probl√©matique, Spring Boot nous offre les starters de d√©pendances qui sont des kits de d√©pendances (vous vous souvenez de mon exemple avec les gammes de meubles, voil√† !  ).

Par exemple, le starter **spring-boot-starter-data-jpa** va vous apporter diff√©rents JAR pour utiliser Spring et JPA, afin de communiquer avec une base de donn√©es.

Tous les starters sont pr√©fix√©s par ‚Äúspring-boot-starter‚Äù. Voici quelques exemples de starters :
- spring-boot-starter-core ;
- spring-boot-starter-data-jpa ;
- spring-boot-starter-security ;
- spring-boot-starter-test ;
- spring-boot-starter-web.

> Comment choisir les bons starters pour mon projet ?

Normalement, la **description du starter** est suffisante pour identifier si ce dernier est ce dont vous avez besoin ou non. Sans oublier que la documentation officielle de Spring saura toujours vous guider vers le bon starter en fonction de vos besoins.

Il n‚Äôy rien de plus √† savoir sur la question, je crois qu‚Äôil est temps de pratiquer !

Il existe deux fa√ßons de cr√©er un projet : avec Spring Initializr et avec Spring Tool suite. Nous allons aborder ces deux approches ensemble !

#### Cr√©ez votre projet avec Spring Initializr

Voyons comment utiliser le site web [Spring Initializr](https://start.spring.io/).

R√©capitulons les √©tapes :
1. J‚Äôai laiss√© par d√©faut Project / Language et Spring Boot.
2. J‚Äôai saisi les informations suivantes dans Project Metadata :
   - Group: com.openclassrooms.
   - Artifact: HelloWorld.
   - Name: HelloWorld.
   - Description: Hello World project with Spring Boot.
   - Package name: com.openclassrooms.helloworld.
   - Packaging: Jar.
   - Java: 8.

Aucune d√©pendance √† ajouter, car le starter ‚Äú**spring-boot-starter**‚Äù, qui contient toutes les fonctionnalit√©s de base, est ajout√© par d√©faut. J‚Äôai cliqu√© sur ‚ÄúGenerate‚Äù, et une archive ZIP avec le projet a √©t√© t√©l√©charg√©e. Apr√®s avoir d√©zipp√© l‚Äôarchive, j‚Äôai tout simplement import√© ce projet existant dans mon IDE.

Voil√†, notre premi√®re √©tape est finie ! 

#### Cr√©ez votre projet avec Spring Tool Suite
Une deuxi√®me fa√ßon d'atteindre le m√™me r√©sultat correspond √† l‚Äôutilisation de l‚Äôoutil Spring Tool Suite, t√©l√©chargeable [ici](https://spring.io/tools).

Je vous conseille **Spring Tools 4 for Eclipse**. Il est t√©l√©chargeable sur Linux, macOS et Windows. Vous obtenez un JAR qui, une fois ex√©cut√©, va cr√©er un r√©pertoire qui aura un nom du style ‚Äústs-4.7.1.RELEASE‚Äù. Au sein de ce r√©pertoire, vous pouvez lancer l‚Äôex√©cutable ‚ÄúSpringToolSuite4.exe‚Äù.

> Spring Tools 4 for Eclipse est un outil d√©velopp√© sur la base de l‚ÄôIDE Eclipse. Les habitu√©s de cet IDE ne seront donc pas d√©pays√©s !

Avez-vous remarqu√© qu‚Äôon retrouve les m√™mes √©tapes, mais cette fois √† travers un outil install√© sur votre poste de travail, et non via un site web ?

> Mais pourquoi utiliser Spring Tool Suite et non Spring Initializr, qui ne demande aucun outil suppl√©mentaire ?

Pour la simple raison que STS (Spring Tool Suite) nous offre une fonctionnalit√© suppl√©mentaire : le ‚Äú**Boot Dashboard**‚Äù, qui permet de g√©rer plus pr√©cis√©ment le **cycle de vie de l‚Äôex√©cution de l‚Äôapplication**. Et comme STS est tout simplement un Eclipse customis√©, on peut directement d√©velopper notre projet au sein de l‚Äôoutil. Assez pratique, finalement. 

Pour finir cette partie, je vous encourage √† jeter un ≈ìil au fichier pom.xml (√† la racine de la structure du projet). Vous y retrouverez tous les √©l√©ments saisis lors de la g√©n√©ration de votre projet. En voici d‚Äôailleurs 2 extraits :

Extrait de la description du projet :
```java
<groupId>com.openclassrooms</groupId>
<artifactId>helloworld</artifactId>
<version>0.0.1-SNAPSHOT</version>
<name>helloworld</name>
<description>Hello World project with Spring Boot</description>
```

Extrait des d√©pendances du projet :
```java
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter</artifactId>
    </dependency>
    ‚Ä¶.
</dependencies>
```

#### En r√©sum√©
- La premi√®re √©tape pour utiliser Spring Boot est de **cr√©er la structure minimale**.
- On obtient la structure minimale en fournissant plusieurs informations, dont **les starters de d√©pendances**.
- Un projet Spring Boot peut √™tre cr√©√© via **Spring Initializr** ou bien via **Spring Tool Suite**.

### Observez la structure minimale
#### Explorez la structure minimale
Voici le projet √† travers la vue Package Explorer de STS. Qu'observez-vous? Comment les sources sont-elles organis√©es ?

Voici quelques points √† noter :
- Nous retrouvons les fichiers li√©s √† Maven (pom.xml, mvnw et mvnw.cmd).
- Nos sources sont organis√©es suivant le sch√©ma standard :
    - src/main/java : contient les packages et les classes Java ;
    - src/main/resources : contient les fichiers ressources, tels que les fichiers de propri√©t√©s ou des templates (HTML, par exemple) ;
    - src/test/java : contient les classes Java de test.
- Comme tout projet Java/Maven, on retrouve √©galement la JRE et les Maven Dependencies.

J‚Äôattire √©galement votre attention sur le fait que cette structure minimale ne contient pas que des r√©pertoires et des packages : il y a aussi deux classes Java et un fichier Propri√©t√©s.

Le fichier de propri√©t√©s ‚Äúapplication.properties‚Äù est cr√©√© par d√©faut, mais il est vide ; j‚Äôy reviendrai plus tard, promis !

Pour ce qui de la classe HelloWorldApplicationTests.java, je ne souhaite pas m‚Äôy arr√™ter non plus √† cette √©tape ; sachez juste pour le moment qu‚Äôelle v√©rifie que le contexte Spring se lance bien comme attendu.

Maintenant, parlons de HelloWorldApplication.java, qui est la **classe principale** de votre projet. On y retrouve 2 choses importantes :
1. La m√©thode main dont je ne vous ferai pas l‚Äôoffense de vous expliquer son r√¥le en Java !
2. L‚Äôannotation @SpringBootApplication qui est critique !

> S T O P ! Annotation, tu dis ?

Vous avez raison, je vais vous expliquer ce qu‚Äôest une annotation, et son utilit√© au sein de Spring.

#### D√©couvrez le r√¥le des annotations et leurs avantages
Nous avons vu ensemble que Spring Framework fournit l‚ÄôIoC container, dans la partie 1 du cours. L‚ÄôIoC container va instancier pour vous des classes, puis si n√©cessaire les injecter dans d‚Äôautres instances de classe. Pour qu‚Äôune classe soit manipul√©e par l‚ÄôIoC container, **il est n√©cessaire de l‚Äôindiquer explicitement √† Spring**. Comment ?

La premi√®re solution est l‚Äôutilisation de **fichiers XML** au sein desquels on d√©crit les classes que Spring doit g√©rer ; voici un exemple des plus simples :
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE beans PUBLIC "-//SPRING//DTD BEAN 2.0//EN"
    "http://www.springframework.org/dtd/spring-beans-2.0.dtd">

<beans>
    <bean id="myBean" class="com.openclassrooms.BeanImpl"/>
</beans>
```

La classe com.openclassrooms.BeanImpl (qui a √©t√© cr√©√©e pr√©alablement, √©videmment) sera ainsi prise en compte par l‚ÄôIoC container.

> Cette solution est l‚Äôune des plus anciennes fa√ßons de faire. Aujourd‚Äôhui, elle est de moins en moins utilis√©e, de par sa complexit√©.

La seconde solution est l‚Äôutilisation des annotations.

Une annotation, c‚Äôest-√†-dire **@[nom de l‚Äôannotation]**, peut √™tre ajout√©e √† une classe, une m√©thode, un attribut. **L‚Äôannotation influe sur le comportement du programme** car elle fournit des m√©tadonn√©es lors de la compilation ; ces m√™mes m√©tadonn√©es seront utilis√©es lors de l‚Äôex√©cution.

Depuis la version 2.5 de Spring, de nombreuses annotations sont fournies, dont le but est de :
1. Permettre √† l‚ÄôIoC container d‚Äô**utiliser nos classes**.
2. **Influer sur le comportement** de Spring.

Voici quelques exemples d‚Äôannotations Spring :
- @Component
- @Autowired
- @Qualifier

> Il n‚Äôy a pas que Spring qui utilise les annotations. Il en existe au sein m√™me de Java, et d‚Äôautres frameworks utilisent aussi ce puissant outil.

Si on reprend l‚Äôexemple pr√©c√©dent, voici la correspondance en annotation :
```java
package com.openclassrooms;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

@Component
@Qualifier(‚ÄúmyBean‚Äù)
public class BeanImpl {
    // TO DO
}
```

L‚Äôannotation @Component permet de d√©clarer la classe BeanImpl aupr√®s de Spring, comme √©tant un bean √† avoir dans l‚ÄôIoC container.

L‚Äôannotation @Qualifier permet de donner un nom √† ce bean, en l'occurrence ‚ÄúmyBean‚Äù (si cette annotation n‚Äôest pas d√©finie, le nom par d√©faut est le nom de la classe).

Qu‚Äôen dites-vous ? C‚Äôest plus sympa, non ? Nul besoin de manipuler du XML, tout se passe dans le Java !

> En r√©alit√©, il n‚Äôy a pas vraiment une meilleure fa√ßon de faire, les 2 sont valides. La configuration via XML est la fa√ßon historique de faire, et on la retrouve encore sur de nombreux projets. Tandis que la configuration par annotations est ce qui s‚Äôutilise de plus en plus, notamment par la d√©mocratisation de Spring Boot.

#### Utilisez l‚Äôannotation @SpringBootApplication
Revenons maintenant √† nos moutons ! Ou plut√¥t √† **l‚Äôannotation @SpringBootApplication**. √Ä quoi sert-elle ?

Comme je vous l‚Äôai expliqu√©, elle va permettre √† l‚ÄôIoC container de manipuler la classe HelloWorldApplication.java. Elle permettra √©galement d‚Äôinfluer sur le comportement de Spring.

@SpringBootApplication est un compos√© de 3 autres annotations :
1. **@SpringBootConfiguration** : la classe sera utilis√©e comme une classe de configuration (on reviendra sur cette notion plus tard).
2. **@EnableAutoConfiguration** : active la fameuse fonctionnalit√© d‚Äôautoconfiguration de Spring Boot, que je vous ai tant vant√©e.
3. **@ComponentScan** : active le ‚Äú**scanning**‚Äù de classes dans le package de la classe et dans ses sous-packages. Sans cette annotation, l‚ÄôIoC container ne tiendra pas compte de vos classes, m√™me si vous avez ajout√© une annotation sur celles-ci. 

OK, on y voit plus clair maintenant ! **En r√©sum√©, cette classe, c‚Äôest ce qui d√©clenche toute la m√©canique interne de Spring Boot et des composants Spring associ√©s**. Et tout √ßa en moins de 15 lignes de code.

Nous voil√† au bout de l‚Äôanalyse de la structure minimale d‚Äôun projet Spring Boot, et quelle conclusion tirons-nous ?

Oui, nous avons une base, c‚Äôest vrai, mais il y a des trous !
1. Au sein de src/main/java, nous avons **un seul package**. Et vu qu‚Äôun d√©veloppeur apprend √† regrouper les classes par sous-ensemble, nous allons devoir **cr√©er des sous-packages** pour nos diff√©rentes classes √† venir.
2. Le fichier applications.properties est vide ! Le pauvre, il doit se sentir bien inutile... Rassurez-vous, on va vite lui donner un r√¥le √† jouer !

Remplissons ces trous pour pouvoir aller de l‚Äôavant !

#### En r√©sum√©
- La structure minimale n‚Äôest pas suffisante, il faut l‚Äôenrichir.
- Les **annotations sont un pilier** au sein de Spring Boot pour tirer profit de l‚ÄôIoC container.
- L‚Äôannotation **@SpringBootApplication** est la concat√©nation de plusieurs annotations, et son objectif est de d√©clencher toute la m√©canique interne de Spring.

### Structurez et configurez votre projet
#### Structurez vos packages
> Comment structurer notre package si on ne conna√Æt pas encore les classes qui seront produites ?

Bonne question, je vois que vous √™tes r√©fl√©chi et que vous avez appris √† ne pas foncer t√™te baiss√©e ! Bravo !

La r√©ponse se veut tr√®s simple : **les bonnes pratiques** !

Premi√®rement, gardons √† l‚Äôesprit que Spring Boot est particuli√®rement utilis√© dans le contexte d‚Äôapplication web (m√™me si √ßa ne se limite pas √† cela).

Deuxi√®mement, la majorit√© des applications ont la n√©cessit√© d'interagir avec des donn√©es externes (par exemple une base de donn√©es, un autre programme, ou m√™me le syst√®me de fichiers).

De ces diff√©rents besoins, une architecture en couches a √©merg√©, avec un r√¥le pour chaque couche :
- **couche Controller** : gestion des interactions entre l‚Äôutilisateur de l‚Äôapplication et l‚Äôapplication ;
- **couche Service** : impl√©mentation des traitements m√©tiers sp√©cifiques √† l‚Äôapplication ;
- **couche Repository** : interaction avec les sources de donn√©es externes ;
- **couche Model** : impl√©mentation des objets m√©tiers qui seront manipul√©s par les autres couches.

[Repr√©sentation visuelle de l'architecture en couches](https://user.oc-static.com/upload/2020/11/10/1605015466847_image11.png)

Cette architecture standard correspondra √† la majorit√© de vos projets, et vous la retrouvez tr√®s fr√©quemment.

> D‚Äôautres packages peuvent √™tre parfois n√©cessaires, par exemple un nomm√© ‚Äúsecurity‚Äù pour les classes d√©di√©es √† la s√©curit√©, ou ‚Äúconfiguration‚Äù pour des classes g√©rant les propri√©t√©s. Dans ce cas, cela s'ajoute √† la structure existante.

Pour √™tre franc, on n'a pas besoin de tous ces packages pour un simple Hello World. Mais dans les parties du cours suivantes, vous les verrez en action.

Dans notre cas, contentons-nous de cr√©er les packages service et model.

#### Compl√©tez le fichier applications.properties
L‚Äô√©tape suivante consiste √† d√©finir quelques informations de base pour notre application, √† travers les propri√©t√©s.

Mais avant, laissez-moi vous en apprendre un peu plus sur Spring et la gestion des propri√©t√©s. Je ne vous apprends rien en vous disant qu‚Äôune application doit √™tre **param√©trable**, c‚Äôest-√†-dire que son comportement peut changer en fonction des param√®tres fournis.

Pour rendre param√©trable une application, elle doit donc √™tre capable de lire ces param√®tres. Mais o√π sont-ils ? Qui les d√©finit ? Comment les lire ?

Ils sont dans des ‚Äú**sources de propri√©t√©s**‚Äù (property sources), et sont d√©finis par les gestionnaires de ces sources.

L√† o√π Spring Boot nous int√©resse, c‚Äôest qu‚Äôil est capable de lire ces sources de propri√©t√©s (sans interaction de notre part), et de rendre les propri√©t√©s disponibles sous forme de beans au sein du contexte Spring.

Parmi les sources de propri√©t√©s, il y a :
- les propri√©t√©s de la JVM ;
- les variables d‚Äôenvironnements du syst√®me d‚Äôexploitation ;
- les arguments pass√©s par la ligne de commande ;
- les fichiers .properties ou .yml (comme *application.properties*).

Vous aurez l‚Äôoccasion de manipuler ces diff√©rentes sources de propri√©t√©s, mais pour le Hello World, on va se contenter de rajouter quelques informations au fichier applications.properties.

> Comment fait-on pour conna√Ætre les propri√©t√©s existantes, vu que application.properties est vide ?

Pour en savoir plus sur les propri√©t√©s de Spring, vous pouvez lire la [documentation de Spring](https://docs.spring.io/spring-boot/docs/current/reference/html/appendix-application-properties.html).

D‚Äôaccord, je vous aide, mettons en place 2 propri√©t√©s :
1. spring.application.name : permet de donner un nom √† notre application Spring Boot.
2. logging.level.[package] : permet d‚Äôindiquer le log level pour un package donn√©.

> Besoin d‚Äôen savoir plus sur les loggers ? Vous pouvez suivre le cours ‚ÄúD√©buggez votre application Java‚Äù, et particuli√®rement le chapitre [‚ÄúFaites des rapports avec un logger, des niveaux de log, et l‚ÄôAPI SLF4J standard‚Äù](https://openclassrooms.com/fr/courses/6692416-debuggez-votre-application-java/6915582-faites-des-rapports-avec-un-logger-des-niveaux-de-log-et-l-api-slf4j-standard).

Voil√† le r√©sultat de mon fichier applications.properties :
```java
spring.application.name=HelloWorld

logging.level.org.springframework=error
```

Quelques explications :
- Ici, le nom est arbitraire ; √† vrai dire, cela n‚Äôaura pas d‚Äôimpact sur le d√©roulement de l‚Äôapplication pour notre Hello World, c‚Äôest surtout informatif. 
- `logging.level.org.springframework=ERROR` : les classes du package org.springframework affichent uniquement les logs de niveau ERROR dans la console (autrement dit, on n‚Äôest pas pollu√© par plein d‚Äôinformations).

C‚Äôest tout ! Nous n‚Äôavons rien √† faire d‚Äôautre, car dans le monde magique de Spring Boot, les propri√©t√©s sont prises en compte automatiquement sans que le d√©veloppeur ait d‚Äôautres actions √† r√©aliser !

#### En r√©sum√©
- Je vous conseille de suivre les bonnes pratiques pour structurer vos packages, et de suivre **un mod√®le en couches**.
    - En l‚Äôoccurrence, nous avons opt√© pour 4 couches : Controller, Service, Repository et Model.
    - L‚Äôapproche en couches permet une meilleure √©volution et une meilleure maintenabilit√© du code.
- Spring Boot a la tr√®s grande capacit√© de savoir lire des **sources de propri√©t√©s**, et le fichier applications.properties en est la d√©monstration. Pour configurer rapidement et efficacement votre application, ajoutez vos propri√©t√©s au fichier applications.properties.

### √âcrivez votre premier Hello World
#### Identifiez o√π et comment √©crire votre code
Le moment tant attendu pour nous d√©veloppeurs est arriv√© ! Nous allons **C-O-D-E-R** !

Pour rappel, nous avons cr√©√© notre projet, puis nous l‚Äôavons structur√© et configur√©. Nous sommes maintenant √† l‚Äô√©tape 3 : nous allons √©crire le code m√©tier, c‚Äôest-√†-dire les traitements fonctionnels attendus. Pour r√©ussir cette √©tape, nous allons devoir nous concentrer sur les beans que Spring doit g√©rer.

> Pour rappel, un **bean est une classe au sein du contexte Spring** (l‚ÄôIoC container).

> Quels sont les besoins fonctionnels pour notre application HelloWorld ?

Rien de plus simple, afficher le texte ‚ÄúHello World!‚Äù dans la console.

> De quoi avons-nous besoin pour atteindre cet objectif ?

**Savoir √©crire dans la console !**

En Java, pour afficher du texte dans la console, la fonction **System.out.println()** permet de le faire. Mais o√π va-t-on placer notre code ?

Reprenons notre classe principale :
```java
package com.test.helloworld;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class HelloworldApplication {

	public static void main(String[] args) {
		SpringApplication.run(HelloworldApplication.class, args);
	}

}
```

La m√©thode main sera th√©oriquement l√† o√π on √©crirait notre code dans un programme Java simple. Mais en l'occurrence, cette derni√®re contient l‚Äôinstruction  `SpringApplication.run(HelloWorldApplication.class, args);`. Cette instruction permet de d√©marrer notre application, et ce n‚Äôest pas une bonne pratique d‚Äôajouter autre chose dans la m√©thode main.

> Oui, mais o√π met-on notre code, alors ?

Spring Boot fournit une interface nomm√©e ‚Äú**CommandLineRunner**‚Äù. En impl√©mentant cette interface, la classe sera oblig√©e de d√©clarer la m√©thode `public void run(String... args) throws Exception`. √Ä partir de l√†, si la classe est un bean (c‚Äôest-√†-dire charg√©e dans le contexte Spring), Spring Boot ex√©cutera la m√©thode run √† l‚Äôex√©cution du programme.

Vous pourriez :
- soit modifier la classe HelloWorldApplication afin qu‚Äôelle impl√©mente CommandLineRunner et la m√©thode run, avec comme corps de m√©thode un ‚ÄúSystem.out.prinln(‚ÄúHello World!‚Äù)‚Äù ;
- soit cr√©er une nouvelle classe qui impl√©mente CommandLineRunner, la m√©thode run (m√™me corps de m√©thode), et qui aura une annotation @Component (au-dessus du nom de la classe).

#### √Ä vous de jouer
Je vous laisse la main, essayez d‚Äôimpl√©menter votre premier HelloWorld !

Pour tester le r√©sultat, si vous utilisez STS via le Boot dashboard, vous pouvez d√©marrer l‚Äôapplication.

Commencez par builder votre application via Maven :
- clic droit sur le nom du projet dans Package Explorer ;
- Run as ;
- Maven install.

Puis lancez l‚Äôapplication via le Boot dashboard :
- sous local, s√©lectionnez votre projet HelloWorld ;
- cliquez sur la premi√®re ic√¥ne du menu.

Voici une solution que je vous propose :
```java
package com.test.helloworld;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class HelloworldApplication implements CommandLineRunner {

	public static void main(String[] args) {
		SpringApplication.run(HelloworldApplication.class, args);
	}
	
	public void run(String... args) throws Exception{
		System.out.println("Hello World!");
	}

}
```

#### Manipulez les beans
> Et les packages service et model, √† quoi servent-ils ?

Nous ne nous sommes pas servi de ces packages car ils n‚Äô√©taient pas utiles pour notre premier Hello World, mais ils le seront pour la suite ! √Ä titre d'entra√Ænement et pour vous faire d√©couvrir d‚Äôautres notions importantes, je vous propose d‚Äô√©crire quelques classes suppl√©mentaires :
- une classe **HelloWorld.java** qui contient un attribut nomm√© **value** de type **String**. Cette classe fait office d‚Äôobjet m√©tier, et doit √™tre dans le **package model**. L‚Äôattribut value doit contenir **le texte ‚ÄúHello World!‚Äù**. On ajoute √©galement une m√©thode **toString** √† cette classe, qui doit retourner le contenu de l‚Äôattribut value ;
- une classe **BusinessService.java** qui contient une m√©thode dont le prototype est ‚Äú**public HelloWorld getHelloWorld()**‚Äù. Cette m√©thode doit instancier un objet HelloWorld, et le retourner. Attention, la classe BusinessService.java doit √™tre d√©clar√©e **en tant que bean dans le context Spring**. J‚Äôen appelle √† votre m√©moire : comment fait-on ?! Via une annotation, bien s√ªr : **@Component** fera l‚Äôaffaire.

Modifions √©galement du code existant :
- La classe HelloWorldApplication doit √™tre compl√©t√©e par un nouvel attribut : ‚Äú**private BusinessService bs;**‚Äù. Ce dernier sera annot√©** @Autowired**.
- Ensuite, la m√©thode run doit √™tre modifi√©e afin qu‚Äôelle contienne le code suivant :
```java
HelloWorld hw = bs.getHelloWorld();
System.out.println(hw);
```

Tout d‚Äôabord, on r√©cup√®re un objet HelloWorld gr√¢ce au BusinessService, puis on transmet l‚Äôobjet HelloWord √† la m√©thode System.out.println. Lors de l‚Äôex√©cution de cette derni√®re, la m√©thode toString() de l‚Äôobjet HelloWorld sera appel√©e, et le texte contenu dans l‚Äôattribut value s‚Äôaffichera.

> Quelque chose m‚Äô√©chappe, l‚Äôattribut bs n‚Äôest jamais instanci√© dans ce code ; comment se fait-il qu‚Äôon puisse l‚Äôutiliser ?

C‚Äôest gr√¢ce √† l‚ÄôIoC container de Spring ! Rappelez-vous, je vous ai appris dans la premi√®re partie le concept de **l‚Äôinjection de d√©pendances**. En mettant l‚Äôannotation @Autowired sur l‚Äôattribut bs, **Spring va chercher au sein de son contexte s‚Äôil existe un bean de type BusinessService**. 

‚úÖ S‚Äôil le trouve, il va alors instancier la classe de ce bean et **injecter cette instance dans l‚Äôattribut**. 

‚ùå S‚Äôil ne trouve pas de bean de ce type, Spring g√©n√®re une erreur.

R√©sultat : nul besoin de g√©rer l‚Äôinstanciation du BusinessService, Spring s‚Äôen occupe pour nous. :-)

#### En r√©sum√©
- Au sein d‚Äôune application Spring Boot, √©crire du code implique de **d√©finir les beans** utilis√©s par Spring.
- On peut ex√©cuter du code gr√¢ce √† l‚Äôimpl√©mentation de l‚Äôinterface **CommandLineRunner** et de la m√©thode **run**.
- Pour qu‚Äôune classe soit **d√©clar√©e en tant que bean**, on l‚Äôannote **@Component**.
- Pour qu‚Äôun bean **soit inject√©** dans un attribut, on annote l‚Äôattribut **@Autowired**.

### D√©couvrez Spring Boot Test et d√©ployez votre projet
#### Abordez la derni√®re √©tape : les tests et le d√©ploiement
C‚Äôest ici la derni√®re ligne droite, et je sens l‚Äôadr√©naline monter! üòÉ

Pour conclure notre application HelloWorld, il nous reste 2 choses √† faire :
1. Tester notre application.
2. D√©ployer notre application.

Pas besoin de vous expliquer que les tests sont utiles, je suis convaincu que vous avez d√©j√† conscience de leur importance.

> Si vous n‚Äô√™tes pas √† l‚Äôaise avec les tests en Java, je vous conseille d‚Äôaller regarder le cours [Testez votre code Java pour r√©aliser des applications de qualit√©](https://openclassrooms.com/fr/courses/6100311-testez-votre-code-java-pour-realiser-des-applications-de-qualite).

‚ÄúD√©ployer‚Äù revient √† mettre en route notre application. Autrement dit, il s‚Äôagit de **passer de l‚Äôenvironnement de d√©veloppement √† l‚Äôenvironnement de production**.

Voyons tout √ßa dans le d√©tail, c‚Äôest parti !

#### D√©couvrez Spring Boot Test
Je vous en ai parl√© pr√©c√©demment, lors de la cr√©ation de la structure minimale du projet, une classe de test a √©t√© cr√©√©e, √† savoir **HelloWorldApplicationTests.java**. Allons la regarder de plus pr√®s ;-) !
```java
package com.openclassrooms.helloworld;

import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class HelloworldApplicationTests {

    @Test
    void contextLoads() { }

}
```

Plut√¥t simple, n‚Äôest-ce pas ? Presque √©tonnant, d‚Äôailleurs ! Expliquons.

**@SpringBootTest** est une annotation fournie par Spring Boot. Elle permet **lors de l‚Äôex√©cution des tests d‚Äôinitialiser le contexte Spring**. Les beans de notre application peuvent alors √™tre utilis√©s.

Rappelons qu‚Äôun test s‚Äôex√©cute de fa√ßon unitaire, presque comme une application √† part enti√®re. Par d√©faut, notre test n‚Äôa donc aucune connaissance du contexte Spring. Dans le cas d‚Äôune application Spring Boot, c‚Äôest un vrai probl√®me !

Mais le probl√®me est r√©solu gr√¢ce √† l‚Äôannotation @SpringBootTest.

La m√©thode contextLoads est **annot√©e @Test** (annotation qui provient de JUnit ; quand je vous disais que d‚Äôautres frameworks utilisent les annotations üòâ), et n‚Äôa pas de contenu.

> Pourquoi n'est elle pas contenu ?

Tout simplement parce que son unique objectif est de **v√©rifier que le contexte Spring se charge bien**.

Sans m√©thode de tests (c‚Äôest-√†-dire sans m√©thode avec @Test), notre classe de test ne peut √™tre ex√©cut√©e, m√™me si elle est annot√©e @SpringBootTest. Pour parer √† cela, Spring Boot g√©n√®re une m√©thode vide annot√©e @Test, et qui sera donc toujours success pour JUnit (car elle est vide).

Ainsi, lors de l‚Äôex√©cution de cette m√©thode, le contexte Spring sera charg√©, et si ce dernier rencontre une erreur, alors l‚Äôex√©cution de la classe de test retournera une erreur.

Tr√®s bien ! Maintenant, testons notre HelloWorld !

> D‚Äôaccord, mais on teste quoi ?

Le but de ce cours n‚Äôest pas de vous expliquer les m√©thodologies de test. Mais rappelez-vous toujours qu‚Äôau sein d‚Äôun projet, on va **tester les traitements m√©tiers** pour s‚Äôassurer qu‚Äôils correspondent bien aux attendus.

Dans notre cas, le traitement m√©tier est repr√©sent√© par la m√©thode getHelloWorld() de la classe BusinessService.

Donc, nous allons tester cette m√©thode.

Je vous laisse essayer, voici quelques indices :
1. Ajoutez une nouvelle m√©thode de test.
2. Injectez une instance de BusinessService dans la classe de test.
3. V√©rifiez que l‚Äôattribut ‚Äúvalue‚Äù de l‚Äôobjet HelloWorld contient bien le texte ‚ÄúHello World!‚Äù.

Ensuite, il ne vous reste plus qu‚Äô√† faire un clic droit sur la classe, ‚ÄúRun As‚Äù, ‚ÄúJUnit Test‚Äù.

```java
package com.test.helloworld;

import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import com.test.helloworld.service.BusinessService;

@SpringBootTest
class HelloworldApplicationTests {

	@Autowired
	private BusinessService bs; 

	@Test
	void contextLoads() {
	}
	
	@Test
	public void testGetHelloWorld() {
		String expected = "Hello World!";
		
		String result = bs.getHelloWorld().getValue();
		
		assertEquals(expected, result);
	}

}
```

Analysons :
- Lignes 14/15 : j‚Äôinjecte une instance de BusinessService dans un attribut nomm√© bs. √Ä noter que sans l‚Äôannotation @SpringBootTest, cela √©chouera car sans contexte Spring, impossible de faire de l‚Äôinjection de d√©pendances.
- Lignes 21/22 : j‚Äô√©cris ma m√©thode, sans oublier d‚Äôannoter @Test.
- Ligne 23 : je d√©finis le r√©sultat attendu pour la valeur ‚ÄúHello World!‚Äù.
- Ligne 25 : je r√©cup√®re, √† travers l‚Äôinstance du BusinessService, un objet HelloWorld, puis j‚Äôappelle la m√©thode getValue et affecte le r√©sultat dans une variable nomm√©e result.
- Ligne 27 : gr√¢ce √† assertEquals, je compare les 2 variables. Si elles sont √©gales, le test r√©ussit, sinon il √©choue.

Allez ! Passons au d√©ploiement !

#### D√©couvrez les m√©thodes de d√©ploiement
Notre objectif est d√©sormais de d√©ployer et ainsi d‚Äôex√©cuter notre application.

> Le d√©ploiement correspond aux √©tapes qui permettent de passer de l‚Äôenvironnement de d√©veloppement √† l‚Äôenvironnement d‚Äôex√©cution.

L‚Äôenvironnement de d√©veloppement correspond g√©n√©ralement √† notre IDE. Dans le cas de ce cours, on utilise STS.

L'environnement d'ex√©cution peut varier. Il peut s'agit d'un environnement de tests ou d'un environnement de production. Notons que l‚Äôenvironnement de d√©veloppement peut √©galement √™tre un environnement d‚Äôex√©cution.

> Quel pr√©requis doit avoir un environnement d‚Äôex√©cution ?
Je suis s√ªr que vous connaissez la r√©ponse : tout simplement une JRE, qui permet ainsi l‚Äôex√©cution d‚Äôun programme Java.

> M√™me si c‚Äôest une application Spring, la simple JRE suffit ?
Tout √† fait, et c‚Äôest une tr√®s bonne nouvelle ! Rappelons que parmi les avantages de Spring Boot, il y a sa facilit√© de d√©ploiement car le JAR qui r√©sulte de la compilation embarque tout.

Par exemple, m√™me le serveur Tomcat qui permet d‚Äôex√©cuter une application web est embarqu√©. Nul besoin d‚Äôinstaller un serveur Tomcat, il est d√©j√† l√† !

R√©capitulons les m√©thodes employ√©es :
- √Ä travers l‚Äô**IDE** avec ‚ÄúRun As‚Äù, ‚ÄúSpring Boot App‚Äù.
- Avec **le goal Maven** `spring-boot:run`.
- **En ex√©cutant le JAR** gr√¢ce √† la commande `java -jar`.

Nous sommes bien d‚Äôaccord, le r√©sultat est le m√™me ! Gardons √† l‚Äôesprit que dans un contexte professionnel, on livrera g√©n√©ralement un JAR, et c‚Äôest ce dernier qui sera ex√©cut√©.

Les m√©thodes de d√©ploiement et d‚Äôex√©cution via l‚ÄôIDE et Maven sont surtout utiles pour les d√©veloppeurs.

#### En r√©sum√©
- Spring Boot fournit une **annotation @SpringBootTest qui permet de charger le contexte Spring** lors de l‚Äôex√©cution des tests.
- D√©ployer une application Spring Boot est tr√®s facile, car l‚Äôartefact qui en r√©sulte est un **simple JAR** o√π tout est embarqu√©.
- Il existe plusieurs m√©thodes pour ex√©cuter notre application Spring Boot :
    - Via l‚ÄôIDE directement.
    - Gr√¢ce √† Maven et au goal spring-boot:run.
    - En ex√©cutant la commande java -jar.

## Partie 3 - Cr√©ez une API avec Spring Boot
### Cr√©ez l'API avec les bons starters
Bienvenue dans la troisi√®me partie du cours sur Spring Boot !

> Que vas-tu nous apprendre, vu que l‚Äôon conna√Æt d√©sormais chaque √©tape pour programmer une application avec Spring Boot ?

Tututu, ne vous emballez pas, il y a tout √† apprendre encore ! C‚Äôest vrai, je vous ai appris √† vous servir du marteau pour planter un clou, mais avez-vous pour autant r√©alis√© un ouvrage digne de ce nom ? Je ne crois pas. 

C‚Äôest justement l‚Äôobjectif de la partie 3 et de la partie 4 de ce cours : r√©aliser des applications avec Spring Boot, qui vont bien au-del√† d‚Äôun simple Hello World ; c‚Äôest-√†-dire **construire un projet digne de ce nom**.

Je vous propose un deal pour chaque √©tape, je vous donne quelques indices, vous essayez puis on corrige.

Autant dire que vous n‚Äôallez pas vous ennuyer ! 

Pr√™t ?! Que la force soit avec vous ! 

#### Plongez-vous dans votre nouvelle mission
[Logo HR Association](https://user.oc-static.com/upload/2020/11/11/1605073055986_18.png)

HR Association est une entreprise qui souhaite offrir un service de gestion d‚Äôemploy√©s aux petites entreprises.

L‚Äôid√©e est d‚Äôoffrir une suite d‚Äôoutils num√©riques (logiciel, application web, voire application mobile) pr√™te √† l‚Äôemploi.

Voici l‚Äôarchitecture imagin√©e :

[Architecture des composants logiciels de HR Association](https://user.oc-static.com/upload/2020/11/11/16050731499577_image9.png)

Pour lancer ce projet, HR Association souhaite avant tout mettre √† disposition une API qui permettra √† toutes les autres applications d‚Äôacc√©der aux m√™mes donn√©es.

Vous allez r√©aliser une **API**. Rappelons-le, une API est un programme qui a pour vocation de **communiquer avec d‚Äôautres programmes**. L‚Äôid√©e √©tant de g√©rer des **employ√©s**, l‚ÄôAPI devra donc offrir un **CRUD** (Create, Read, Update, Delete) pour les donn√©es des employ√©s.

Les donn√©es seront dans une **base de donn√©es H2** (pour ceux qui sont un peu initi√©s aux bases de donn√©es, n‚Äôh√©sitez pas √† faire du MySQL, PostgreSQL ou autre).

> H2 est une base de donn√©es relationnelle Java tr√®s l√©g√®re, qui par d√©faut fonctionne en ‚Äúin memory‚Äù. Cela signifie qu‚Äôau d√©marrage du programme, la structure de la base est construite ; et lorsque le programme s‚Äôarr√™te, le contenu de la base de donn√©es est supprim√©. On ne conserve donc pas les modifications apport√©es d‚Äôune ex√©cution √† l‚Äôautre du programme.

Notre API devra donc **exposer des endpoints** correspondant aux actions du CRUD, et **communiquer avec la base de donn√©es** pour r√©cup√©rer ou modifier les informations des employ√©s. √Ä noter que l‚ÄôAPI sera de type **REST**.

> Besoin de d√©couvrir les API REST ? Par ici avec le cours [Adoptez les API REST pour vos projets web](https://openclassrooms.com/fr/courses/6573181-adoptez-les-api-rest-pour-vos-projets-web).

#### √Ä vous de jouer
Vous souvenez-vous de la premi√®re √©tape ? **Cr√©er la structure minimale du projet en d√©finissant les bons starters** !

Prenez en compte les besoins techniques de l‚Äôapplication, cherchez les starters dans la liste existante, et **regardez avec soin les descriptions** pour identifier ceux qui vous sont n√©cessaires ! On se retrouve dans quelques minutes pour la correction.

#### Correction : identifiez les bons starters pour cr√©er l'API
Quelques explications :
- Pour les ‚ÄúProject Metadata‚Äù, je suis rest√© simple :
    - group: com.openclassrooms (un standard) ;
    - artifact: api (on ‚Äúappelle un chat un chat‚Äù, n‚Äôest-ce pas ?).
- Pour les d√©pendances :
    - **Spring Web** : comme la description l‚Äôindique, permet de faire du RESTful, ce qui correspond √† notre API pour exposer des endpoints.
    - **Lombok** : vous ne pouviez pas le deviner, c‚Äôest une librarie pour optimiser certaines classes, je vous en parle un peu plus loin dans le chapitre.
    - **H2 Database** : comme on dit, ‚ÄúC'est comme le Port-Salut, c'est √©crit dessus‚Äù ; on veut faire du H2, alors on prend cette d√©pendance.
    - **Spring Data JPA** : permet de g√©rer la persistance des donn√©es avec la base de donn√©es ; peut-√™tre le plus difficile √† identifier pour vous si vous n‚Äôavez jamais fait de persistance de donn√©es avec Spring.



